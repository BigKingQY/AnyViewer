/******************************************************************************
* 
* CAPSAEMAIL
* Version
* Copyright (C) 2002, 2003 Colasoft Co., Ltd.
* All Rights Reserved
* $Header: /cvsdata/vc/SaxIDE/Common/StreamManager.h,v 1.3 2015/08/17 01:06:44 administrator Exp $
* 
*******************************************************************************
* 
* Description:邮件流管理类申明,它避免大量的内存拷贝
******************************************************************************/
#pragma once


class CStreamManager
{
public:
	CStreamManager(int nMaxBufferSize = 10240)
		: m_nMaxBufferSize(nMaxBufferSize)
		, m_pBuffer(nullptr)
		, m_nBufferSize(0)
		, m_nBufferDataLen(0)
		, m_pSteamData(nullptr)
		, m_nSteamDataLen(0)
	{		
	}
	virtual ~CStreamManager(void)
	{
		DestroyBuffer();
	}
public:
	int  GetLength() const       { return m_nBufferDataLen + m_nSteamDataLen;}
	
	unsigned char* GetSteamDataPtr() { return m_pSteamData;}
	
	int   GetSteamDataLen() const { return m_nSteamDataLen;}

public:
	void Clear();
	
	void AddTail(unsigned char* pNewSteam,int nNewSteamLen);	
	
	unsigned char GetAt(int nIndex) const;

	int  Find(const char* psz, const int nLen, const int nStartPos, int nEndPos = -1,const int* pShitTable = nullptr) const;
	
	int  Find(std::string& strSub, const int nStartPos, const int nEndPos = -1,const int* pShitTable = nullptr) const;
	
	void GetAsANSIString(const int nStartPos,int nLen,std::string& strResult) const;

	void CopyStreamtoBuffer(char* pBuffer, const int nStartPos, const int nLen) const;


	bool SaveRemainData(const int nStartPos); 

	bool CompareNoCase(const char* psz, const int nLen, const int nStartPos) const;
	
	int  UTF8ToAnsi(char* pOutBuffer, const int nBufferLen, const int nStartPos, const int nLen) const;
	
	// 把管理器中指定的URL字符串转换为ANSI字符串
	int  URLDecode(char* pOutBuffer,int nStartPos,const int nLen) const;

	unsigned char* GetBufferPtr(int nStartPos,int nEndPos,int& nLen);
public:
	bool AllocateBuffer(int nBufferSize);
	
	void DestroyBuffer();

private:
	int     m_nMaxBufferSize;         //缓冲区的最大尺寸
	unsigned char*   m_pBuffer;                //用于存储分析剩下的数据
	int     m_nBufferSize;            //当前缓冲区的尺寸
	int     m_nBufferDataLen;         //缓冲区中分析剩下的数据数据长度
	unsigned char*   m_pSteamData;             //新的数据流指针
    int     m_nSteamDataLen;          //新的数据流的长度	
};

