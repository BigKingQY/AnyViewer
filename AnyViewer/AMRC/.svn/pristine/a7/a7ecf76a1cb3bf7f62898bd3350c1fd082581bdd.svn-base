/******************************************************************************
* 
* SSPAEPT
* Version
* Copyright (C) 2002, 2003 Ax3soft Co., Ltd.
* All Rights Reserved
* $Header: /cvsdata/vc/SaxIDE/Common/CalcNumericForm.h,v 1.4 2015/08/17 01:06:44 administrator Exp $
* 
*******************************************************************************
* 
* Description:条件表达式计算相关类定义
******************************************************************************/
#pragma once
//#include "Typedef.h"
#include "IDEFieldDefine.h"
#include "log.h"
#include <vector>
#include <map>
#include <sstream>
#include <unordered_map>


namespace LOGIC_FORM
{

//#ifdef WIN32 
//#define LOG_DEBUG(fmt, args...)	LOG_DEBUG("%s(%d): " fmt, __FILE__, __LINE__, ##args)
//#else
//#define LOG_DEBUG(fmt, args...)	do{}while(0)
//#endif 



	const float MISTAKE = (float)0.00001;    //浮点数比较的误差


	union unMacAddr
	{
		int64_t nIntAddr;
		unsigned char     aryAddr[8];
	};

	enum CSTOKEN_TYPE  //符号类型常量
	{
		TT_ERR         = 0,     //错误符号    
		TT_OR          = 1,     //"||"
		TT_AND         = 2,     //"&&"
		TT_NOT         = 3,     //"!"
		TT_MOR         = 4,     //">"
		TT_LES         = 5,     //"<"
		TT_EQU         = 6,     //"="
		TT_UNEQ        = 7,     //"!="
		TT_MEQ         = 8,     //">="
		TT_LEQ         = 9,     //"<="
		TT_PLUS        = 10,    //"+"
		TT_MINUS       = 11,    //"-"
		TT_MULT        = 12,    //"*"
		TT_DIVI        = 13,    //"/"
		TT_BITAND      = 14,    //"&"
		TT_EXCOR       = 15,    //"^"
		TT_BITOR       = 16,    //"|"
		TT_LPAREN      = 17,    //"("
		TT_RPAREN      = 18,    //")"
		TT_STR         = 19,    //字符串型常量
		TT_INT         = 20,    //整数型常量
		TT_FLOAT       = 21,    //浮点数型常量
		TT_UNKNOWN_VAR = 22,    //未知变量
		TT_LONG_VAR    = 23,    //整型变量
		TT_FLOAT_VAR   = 24,    //浮点数变量
		TT_STRING_VAR  = 25,    //字符串变量 
		TT_NETIP       = 26,    //ip地址转换函数
		TT_NETMAC      = 27,    //Mac地址转换函数
		TT_NODFUN      = 28,    //节点函数调用
		TT_PROTOCOLFUN = 29     //协议函数调用
	};

	class CIDEVariant 
	{
		// Constructors
	public:
		CIDEVariant()	
			: vt(SSIDE_FT_UNKNOWN)
		{	
			memset(&decVal,0,sizeof(decVal));
		}
		~CIDEVariant()
		{
		}
		CIDEVariant(const CIDEVariant& varSrc)
		{
			*this = varSrc;
		}

		CIDEVariant(LPCSTR lpszSrc)
		{
			*this = lpszSrc;
		}

		CIDEVariant(bool bSrc)
		{
			vt = SSIDE_FT_BOOL;
			decVal.boolVal = bSrc ? true : false;
		}

		CIDEVariant(int nSrc, SSIDE_FIELD_DATA_TYPE vtSrc = SSIDE_FT_I4) 
		{
			assert(vtSrc == SSIDE_FT_I4);
			vt = vtSrc;
			decVal.intVal = nSrc;
		}
		CIDEVariant(unsigned char nSrc)
		{
			vt = SSIDE_FT_I1;
			decVal.bVal = nSrc;
		}
		CIDEVariant(short nSrc)
		{
			vt = SSIDE_FT_I2;
			decVal.iVal = nSrc;
		}
		//CIDEVariant(int nSrc, SSIDE_FIELD_DATA_TYPE vtSrc = SSIDE_FT_I4)
		//{
		//	assert(vtSrc == SSIDE_FT_I4);
		//	vt = vtSrc;
		//	decVal.intVal = nSrc;
		//}
		CIDEVariant(float fltSrc)
		{
			vt = SSIDE_FT_R4;
			decVal.fltVal = fltSrc;
		}
		CIDEVariant(double dblSrc, SSIDE_FIELD_DATA_TYPE vtSrc = SSIDE_FT_R8)
		{
			assert(vtSrc == SSIDE_FT_R8 || vtSrc == SSIDE_FT_DATE);
			vt = vtSrc;
			decVal.dblVal = dblSrc;
		}
		CIDEVariant(int64_t nSrc)
		{
			vt = SSIDE_FT_I8;
			decVal.llVal = nSrc;
		}
		CIDEVariant(uint64_t nSrc)
		{
			vt = SSIDE_FT_UI8;
			decVal.ullVal = nSrc;
		}	

		CIDEVariant(unsigned short nSrc)
		{
			vt = SSIDE_FT_UI2;
			decVal.uiVal = nSrc;
		}

		CIDEVariant(unsigned int nSrc, SSIDE_FIELD_DATA_TYPE vtSrc = SSIDE_FT_UI4) throw()
		{
			assert(vtSrc == SSIDE_FT_UI4);
			vt = vtSrc;
			decVal.uintVal= nSrc;
		}

		// Assignment Operators
	public:
		CIDEVariant& operator=(const CIDEVariant& varSrc)
		{
			vt     = varSrc.vt;
			decVal = varSrc.decVal;
			strVal = varSrc.strVal;
			return *this;
		}	

		CIDEVariant& operator=(LPCSTR lpszSrc)
		{	
			if(lpszSrc != nullptr)
			{
				strVal = lpszSrc;
				vt = SSIDE_FT_BSTR;
			}
			else
			{
				vt = SSIDE_FT_ERROR;
			}
			return *this;
		}
		CIDEVariant& operator=(char* lpszSrc)
		{	
			if(lpszSrc != nullptr)
			{
				strVal = lpszSrc;
				vt = SSIDE_FT_BSTR;
			}
			else
			{
				vt = SSIDE_FT_ERROR;
			}
			return *this;
		}

		CIDEVariant& operator=(const std::string& refSrc)
		{
			strVal = refSrc;
			vt = SSIDE_FT_BSTR;

			return *this;
		}

		CIDEVariant& operator=(bool bSrc)
		{
			vt      = SSIDE_FT_BOOL;
			decVal.boolVal = bSrc ? true : false;
			return *this;
		}

		CIDEVariant& operator=(int nSrc) throw()
		{
			vt     = SSIDE_FT_I4;
			decVal.intVal = nSrc;

			return *this;
		}

		CIDEVariant& operator=(unsigned char nSrc) throw()
		{
			vt      = SSIDE_FT_I1;
			decVal.bVal    = nSrc;
			return *this;
		}

		CIDEVariant& operator=(short nSrc) throw()
		{
			vt   = SSIDE_FT_I2;
			decVal.iVal = nSrc;
			return *this;
		}

		CIDEVariant& operator=(float fltSrc) throw()
		{
			vt     = SSIDE_FT_R4;
			decVal.fltVal = fltSrc;
			return *this;
		}

		CIDEVariant& operator=(double dblSrc) throw()
		{
			vt     = SSIDE_FT_R8;
			decVal.dblVal = dblSrc;
			return *this;
		}	

		CIDEVariant& operator=(unsigned short nSrc) throw()
		{
			vt     = SSIDE_FT_UI2;
			decVal.uiVal = nSrc;
			return *this;
		}

		CIDEVariant& operator=(unsigned int nSrc) throw()
		{
			vt     = SSIDE_FT_UI4;
			decVal.uintVal = nSrc;
			return *this;
		}

		//CIDEVariant& operator=(unsigned int nSrc) throw()
		//{
		//	vt     = SSIDE_FT_UI4;
		//	decVal.uintVal= nSrc;
		//	return *this;
		//}	


		CIDEVariant& operator=(uint64_t nSrc) throw()
		{
			vt     = SSIDE_FT_UI8;
			decVal.ullVal = nSrc;

			return *this;
		}	


		// Comparison Operators
	public:
		bool operator==(const CIDEVariant& varSrc)
		{
			// For backwards compatibility
			assert(vt == varSrc.vt);
			switch(vt)
			{
			case SSIDE_FT_I1:
				return (decVal.bVal == varSrc.decVal.bVal);
				break;

			case SSIDE_FT_I2:
				return (decVal.iVal == varSrc.decVal.iVal);
				break;

			case SSIDE_FT_I4:
				return (decVal.intVal == varSrc.decVal.intVal);
				break;

			case SSIDE_FT_I8:
				return (decVal.llVal == varSrc.decVal.llVal);
				break;

			case SSIDE_FT_R4:
				return (decVal.fltVal == varSrc.decVal.fltVal);
				break;

			case SSIDE_FT_R8:
				return (decVal.dblVal == varSrc.decVal.dblVal);
				break;

			case SSIDE_FT_BOOL:
				return (decVal.boolVal == varSrc.decVal.boolVal);
				break;

			case SSIDE_FT_BSTR:
				return (strVal == varSrc.strVal);
				break;

			case SSIDE_FT_UI2:
				return (decVal.uiVal == varSrc.decVal.uiVal);
				break;

			case SSIDE_FT_UI4:
				return (decVal.uintVal == varSrc.decVal.uintVal);
				break;

			case SSIDE_FT_UI8:
				return (decVal.ullVal == varSrc.decVal.ullVal);
				break;
			default:
				assert(false);
			}

			return false;
		}

		bool operator!=(const CIDEVariant& varSrc) 
		{
			return !operator==(varSrc);
		}

		bool operator<(const CIDEVariant& varSrc)
		{
			assert(vt == varSrc.vt);

			switch(vt)
			{
			case SSIDE_FT_I1:
				return (decVal.bVal < varSrc.decVal.bVal);
				break;

			case SSIDE_FT_I2:
				return (decVal.iVal < varSrc.decVal.iVal);
				break;

			case SSIDE_FT_I4:
				return (decVal.intVal < varSrc.decVal.intVal);
				break;

			case SSIDE_FT_I8:
				return (decVal.llVal < varSrc.decVal.llVal);
				break;

			case SSIDE_FT_R4:
				return (decVal.fltVal < varSrc.decVal.fltVal);
				break;

			case SSIDE_FT_R8:
				return (decVal.dblVal < varSrc.decVal.dblVal);
				break;

			case SSIDE_FT_BOOL:
				return (decVal.boolVal < varSrc.decVal.boolVal);
				break;

			case SSIDE_FT_BSTR:
				return (strVal < varSrc.strVal);
				break;


			case SSIDE_FT_UI2:
				return (decVal.uiVal < varSrc.decVal.uiVal);
				break;

			case SSIDE_FT_UI4:
				return (decVal.uintVal < varSrc.decVal.uintVal);
				break;

			case SSIDE_FT_UI8:
				return (decVal.ullVal < varSrc.decVal.ullVal);
				break;
			default:
				assert(false);
			}
			return false;
		}

		bool operator<=(const CIDEVariant& varSrc)
		{
			return !operator>(varSrc);
		}

		bool operator>(const CIDEVariant& varSrc)
		{
			assert(vt == varSrc.vt);
			switch(vt)
			{
			case SSIDE_FT_I1:
				return (decVal.bVal > varSrc.decVal.bVal);
				break;

			case SSIDE_FT_I2:
				return (decVal.iVal > varSrc.decVal.iVal);
				break;

			case SSIDE_FT_I4:
				return (decVal.intVal > varSrc.decVal.intVal);
				break;

			case SSIDE_FT_I8:
				return (decVal.llVal > varSrc.decVal.llVal);
				break;

			case SSIDE_FT_R4:
				return (decVal.fltVal > varSrc.decVal.fltVal);
				break;

			case SSIDE_FT_R8:
				return (decVal.dblVal > varSrc.decVal.dblVal);
				break;

			case SSIDE_FT_BOOL:
				return (decVal.boolVal > varSrc.decVal.boolVal);
				break;

			case SSIDE_FT_BSTR:
				return (strVal > varSrc.strVal);
				break;

			case SSIDE_FT_UI2:
				return (decVal.uiVal > varSrc.decVal.uiVal);
				break;

			case SSIDE_FT_UI4:
				return (decVal.uintVal > varSrc.decVal.uintVal);
				break;

			case SSIDE_FT_UI8:
				return (decVal.ullVal > varSrc.decVal.ullVal);
				break;

			default:
				assert(false);
			}
			return false;
		}
		bool operator>=(const CIDEVariant& varSrc)
		{
			return !operator<(varSrc);
		}
	public:
		operator unsigned char() const       { return decVal.bVal;}
		operator short() const      { return decVal.iVal;}
		operator int() const        { return decVal.intVal;}
		operator int64_t() const   { return decVal.llVal;}
		operator unsigned short() const     { return decVal.uiVal;}
		operator unsigned int() const       { return decVal.uintVal;}
		operator uint64_t() const  { return decVal.ullVal;}
		operator float() const      { return decVal.fltVal;}
		operator double() const     { return decVal.dblVal;} 
		//operator int64_t() const { return decVal.llVal; }
		//operator uint64_t() const { return decVal.ullVal; }
	public:
		void ConvertToStr(std::string& strResult) const    
		{ 
			std::stringstream ssResult;

			switch(vt)
			{
			case SSIDE_FT_I1:
				ssResult << decVal.bVal;				
				break;

			case SSIDE_FT_I2:
				ssResult << decVal.iVal;
				break;

			case SSIDE_FT_I4:
				ssResult << decVal.intVal;
				break;

			case SSIDE_FT_I8:
				ssResult << decVal.llVal;
				break;

			case SSIDE_FT_R4:
				ssResult << decVal.fltVal;
				break;

			case SSIDE_FT_R8:
				ssResult << decVal.dblVal;
				break;

			case SSIDE_FT_BOOL:
				ssResult << decVal.boolVal;
				break;

			case SSIDE_FT_BSTR:
				ssResult << strVal.c_str();
				break;

			case SSIDE_FT_UI2:
				ssResult << decVal.uiVal;
				break;

			case SSIDE_FT_UI4:
				ssResult << decVal.uintVal;
				break;

			case SSIDE_FT_UI8:
				ssResult << decVal.ullVal;
				break;
			default:
				assert(false);
			}

			strResult = ssResult.str();
		}
	public: 
		void AssignMac(unsigned char* pMac)
		{
			vt = SSIDE_FT_I8;
			decVal.llVal = 0;
			memcpy(&decVal.llVal,pMac,6);
		}
	private:		
		SSIDE_FIELD_DATA_TYPE vt;
		std::string          strVal;
		union 
		{
			unsigned char         bVal;
			unsigned short        iVal;
			int          intVal;
			int64_t     llVal;
			unsigned short       uiVal;
			unsigned int         uintVal;	
			uint64_t    ullVal; 
			float        fltVal;
			double       dblVal;
			bool boolVal;
		}decVal;
	};



	//////////////////////////////////////////////////////////////
	//上下文基类
	class CContext
	{
	public:
		CContext()
		{
		}		
		virtual bool GetVariableValue(int /*nVariableIdx*/,CIDEVariant&  /*pvarResult*/) {return false;}
		virtual bool Call(CSTOKEN_TYPE /*nFunctionType*/,int64_t& /*refReturn*/,int /*nArgCount*/,...) {return false;}
	};


	class CCondition;


	class CTreeNode
	{
	public:
		CTreeNode()
			: m_pParent(nullptr)
			, m_pLeft(nullptr)
			, m_pRight(nullptr)
			, m_bIsOnTree(false)
		{
		}
		virtual ~CTreeNode()
		{		
		}	
		void SetParent(CTreeNode* pParent)
		{m_pParent = pParent;}
		CTreeNode* GetParent() { return m_pParent;}
		void SetLeft(CTreeNode* pLeft) { m_pLeft = pLeft;}
		CTreeNode* GetLeft() { return m_pLeft;}
		void SetRight(CTreeNode* pRight) { m_pRight = pRight;}
		CTreeNode* GetRight() { return m_pRight;}
		void SetIsOnTree(bool bOnTree) 
		{ 
			m_bIsOnTree = bOnTree;
			if(!bOnTree)
			{
				m_pParent = nullptr;
				m_pLeft = nullptr;
				m_pRight = nullptr;
			}
		}
		bool GetIsOnTree() { return m_bIsOnTree;}
		void SetTokenType(CSTOKEN_TYPE ttTokenType) { m_ttTokenType = ttTokenType;}
		CSTOKEN_TYPE GetTokenType() { return m_ttTokenType;}

	public:
		virtual void Reset()                       //复位节点状态
		{
			if(nullptr != m_pLeft)
			{
				m_pLeft->Reset();
			}
			if(nullptr != m_pRight)
			{			
				m_pRight->Reset();
			}		
		};
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			for(unsigned int i = 0; i < s_nIndent; i++ ) 
			{
				LOG_DEBUG(" ");
			}
		}
		virtual void ShowTree()
		{
			s_nIndent++;
			ShowNoe();

			if(nullptr != m_pLeft)
			{
				m_pLeft->ShowTree();
			}			
			if(nullptr != m_pRight)
			{			
				m_pRight->ShowTree();
			}
			s_nIndent--;
		}	
#endif
	public:
		static unsigned int      s_nIndent;
	protected:
		CTreeNode*       m_pParent;
		CTreeNode*       m_pLeft;
		CTreeNode*       m_pRight;
		bool             m_bIsOnTree;
		CSTOKEN_TYPE     m_ttTokenType;
	};


	class CFactor;

	class CExpression
		: public CTreeNode
	{
	public:
		CExpression()
		{
		}	
	public:
		virtual CFactor* Evaluate(CContext* objContext) = 0;
	};

	class CFactor :public CExpression
	{
	public:
		CFactor()
		{}
		virtual ~CFactor()
		{}
	public:
		virtual CFactor* operator+( CFactor* pFactor) = 0; 
		virtual CFactor* operator-( CFactor* /*pFactor*/) { return this;}
		virtual CFactor* operator*( CFactor* /*pFactor*/) { return this;}
		virtual CFactor* operator/( CFactor* /*pFactor*/) { return this;}
		virtual CFactor* operator&( CFactor* /*pFactor*/) { return this;}
		virtual CFactor* operator^( CFactor* /*pFactor*/) { return this;}
		virtual CFactor* operator|( CFactor* /*pFactor*/) { return this;}
		virtual bool    operator>( CFactor* pFactor) = 0;
		virtual bool    operator<( CFactor* pFactor) = 0;
		virtual bool    operator==( CFactor* pFactor) = 0;	
		virtual bool    operator>=( CFactor* pFactor) = 0;
		virtual bool    operator<=( CFactor* pFactor) = 0;
		virtual bool    operator!=( CFactor* pFactor) = 0;
		operator bool()  { return (bool)GetValueAsInt();} 
	public:
		virtual int64_t GetValueAsInt()    { return 0;}
		virtual float   GetValueAsFloat()   { return 0;}
		virtual std::string  GetValueAsString() { return ""; }
	};


	///////////////////////////////////////////////////////////////////////
	//整数元素类
	class CIntFactor:public CFactor
	{
	public:
		CIntFactor(int64_t nVal = 0)
			: m_nValue(nVal)
			, m_nInitValue(nVal)
		{
		}
		virtual ~CIntFactor()
		{
		}
		void SetInitVal(int64_t nInitValue)
		{
			m_nValue = nInitValue;
			m_nInitValue = nInitValue;
		}	
		virtual int64_t GetValueAsInt()   { return m_nValue;}
		virtual float   GetValueAsFloat()  { return float(m_nValue);}
	public:
		virtual CFactor* Evaluate(CContext* /*objContext*/)	{ return this;}

		virtual CFactor* operator+( CFactor* pFactor)
		{
			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				m_nValue += pFactor->GetValueAsInt();	
			}			

			return this;
		}
		virtual CFactor* operator-( CFactor* pFactor)
		{
			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				m_nValue -= pFactor->GetValueAsInt();	
			}


			return this;
		}
		virtual CFactor* operator*( CFactor* pFactor)
		{ 		
			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				m_nValue *= pFactor->GetValueAsInt();	
			}			

			return this;
		}
		virtual CFactor* operator/( CFactor* pFactor)
		{
			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				if(pFactor->GetValueAsInt() != 0)
				{
					m_nValue /= pFactor->GetValueAsInt();
				}
				else
				{
					LOG_DEBUG("除数不能为零！\n");
				}
			}

			return this;	
		}
		virtual CFactor* operator&( CFactor* pFactor)
		{		
			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				m_nValue &= pFactor->GetValueAsInt();
			}


			return this;
		}

		virtual CFactor* operator^( CFactor* pFactor)
		{
			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				m_nValue ^= pFactor->GetValueAsInt();
			}			

			return this;
		}
		virtual CFactor* operator|( CFactor* pFactor)
		{		
			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				m_nValue |= pFactor->GetValueAsInt();
			}

			return this;
		}

		virtual bool  operator>( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				bResult = (m_nValue > pFactor->GetValueAsInt());
			}

			return bResult;
		}
		virtual bool operator<( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				bResult = (m_nValue < pFactor->GetValueAsInt());
			}

			return bResult;
		}
		virtual bool    operator==( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				bResult = (m_nValue == pFactor->GetValueAsInt());
			}

			return bResult;
		}
		virtual bool    operator>=( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				bResult = (m_nValue >= pFactor->GetValueAsInt());
			}

			return bResult;
		}
		virtual bool operator<=( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				bResult = (m_nValue <= pFactor->GetValueAsInt());
			}

			return bResult;
		}
		virtual bool    operator!=( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				bResult = (m_nValue != pFactor->GetValueAsInt());
			}

			return bResult;
		}
		void Reset()
		{
			m_nValue = m_nInitValue;
			CTreeNode::Reset();
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("%I64d\n",m_nValue);
		}	
#endif
	protected:
		int64_t m_nValue;
		int64_t m_nInitValue;
	};

	///////////////////////////////////////////////////////////////////////
	//浮点数元素类
	class CFloatFactor:public CFactor
	{
	public:
		CFloatFactor(float nVal = 0.0)
			: m_nValue(nVal)
			, m_nInitValue(nVal)
		{
		}
		virtual ~CFloatFactor()
		{
		}
		void SetInitVal(float nInitValue)
		{
			m_nValue = nInitValue;
			m_nInitValue = nInitValue;
		}
		virtual float   GetValueAsFloat() { return m_nValue;}
		virtual int64_t GetValueAsInt()   { return (int64_t)m_nValue; }
	public:
		virtual CFactor* Evaluate(CContext* /*objContext*/)	{return this;}
		virtual CFactor* operator+( CFactor* pFactor)
		{
			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				m_nValue += pFactor->GetValueAsFloat();	
			}

			return this;
		}
		virtual CFactor* operator-( CFactor* pFactor)
		{
			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				m_nValue -= pFactor->GetValueAsFloat();	
			}

			return this;
		}
		virtual CFactor* operator*( CFactor* pFactor)
		{ 
			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				m_nValue *= pFactor->GetValueAsFloat();	
			}

			return this;
		}
		virtual CFactor* operator/( CFactor* pFactor)
		{
			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				if(pFactor->GetValueAsFloat() == 0)
				{
					m_nValue /= pFactor->GetValueAsFloat();
				}
				else
				{
					LOG_DEBUG("除数不能为零!\n");
				}
			}
			return this;
		}
		virtual bool  operator>( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				bResult = (m_nValue - MISTAKE  > pFactor->GetValueAsFloat());
			}

			return bResult;
		}
		virtual bool operator<( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				bResult = (m_nValue + MISTAKE < pFactor->GetValueAsFloat());
			}

			return bResult;
		}
		virtual bool    operator==( CFactor* pFactor)
		{
			bool bResult = false;
			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				bResult = ((m_nValue - pFactor->GetValueAsFloat()) > -MISTAKE ||
					(m_nValue - pFactor->GetValueAsFloat()) < MISTAKE );
			}

			return bResult;
		}
		virtual bool    operator>=( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				bResult = (m_nValue - MISTAKE >= pFactor->GetValueAsFloat());
			}

			return bResult;
		}
		virtual bool operator<=( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				bResult = (m_nValue + MISTAKE <= pFactor->GetValueAsFloat());
			}

			return bResult;
		}
		virtual bool    operator!=( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);
			bResult = (!(this == pFactor));

			return bResult;
		}

		void Reset()
		{
			m_nValue = m_nInitValue;
			CTreeNode::Reset();
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("%f\n",m_nValue);
		}	
#endif
	protected:
		float m_nValue;
		float m_nInitValue;
	};
	///////////////////////////////////////////////////////////////////
	//字符串计算元素
	class CStringFactor:public CFactor
	{
	public:
		CStringFactor()
		{
		}

		CStringFactor(std::string strVal)
			: m_strValue(strVal)
			, m_strInitValue(strVal)
		{
		}
		virtual ~CStringFactor()
		{
		}
		void SetInitVal(std::string strInitValue)
		{
			m_strInitValue = strInitValue;
			m_strValue = strInitValue;
		}
		virtual std::string  GetValueAsString() { return m_strValue;}
	public:
		virtual CFactor* Evaluate(CContext* /*objContext*/)	{return this;}

		virtual CFactor* operator+( CFactor* pFactor)
		{
			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				m_strValue += pFactor->GetValueAsString();	
			}

			return this;
		}
		virtual bool operator>( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				bResult = (m_strValue > pFactor->GetValueAsString());
			}

			return bResult;
		}
		virtual bool    operator<( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				bResult = (m_strValue < pFactor->GetValueAsString());
			}

			return bResult;
		}
		virtual bool    operator==( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				bResult = (m_strValue == pFactor->GetValueAsString());
			}

			return bResult;
		}
		virtual bool    operator>=( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				bResult = (m_strValue >= pFactor->GetValueAsString());
			}

			return bResult;
		}
		virtual bool operator<=( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);	
			if(nullptr != pFactor)
			{
				bResult = (m_strValue <= pFactor->GetValueAsString());
			}

			return bResult;
		}

		virtual bool    operator!=( CFactor* pFactor)
		{
			bool bResult = false;

			assert(nullptr != pFactor);
			if(nullptr != pFactor)
			{
				bResult = (m_strValue != pFactor->GetValueAsString());
			}

			return bResult;
		}
		void Reset()
		{
			m_strValue = m_strInitValue;
			CTreeNode::Reset();
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("%s\n",m_strValue);
		}	
#endif
	protected:
		std::string m_strValue;
		std::string m_strInitValue;
	};
	class CVaribleInfo
	{
	public:
		CVaribleInfo()
			: m_strName("")
			, m_dtType(TT_LONG_VAR)
			, m_nIndex(0)
		{
		}
		CVaribleInfo(std::string& strName,CSTOKEN_TYPE  dtType,int nIndex)
			: m_strName(strName)
			, m_dtType(dtType)
			, m_nIndex(nIndex)
		{
		}
	public:
		void SetName(std::string& strName) { m_strName = strName;}
		std::string GetName() { return m_strName;}
		void SetType(CSTOKEN_TYPE  dtType) { m_dtType = dtType;}
		CSTOKEN_TYPE GetType() { return m_dtType;}
		void SetIndex(int nIndex) { m_nIndex = nIndex;}
		int GetIndex() { return m_nIndex;}
		void Copy(const CVaribleInfo& refVar)
		{
			m_strName = refVar.m_strName;
			m_dtType = refVar.m_dtType;
			m_nIndex = refVar.m_nIndex;
		}
	private:
		std::string    m_strName;
		CSTOKEN_TYPE  m_dtType;	
		int        m_nIndex;
	};


	///////////////////////////////////////////////////////////////////
	//变量计算元素基类
	class CVaribleFactor
	{
	public:
		CVaribleFactor()
			: m_strName("")
			, m_nIndex(0)
		{}
		CVaribleFactor(std::string& strName,int nIndex)
			: m_strName(strName)
			, m_nIndex(nIndex)
		{}
	public:	
		void SetName(std::string& strName) { m_strName = strName;}
		std::string GetName() { return m_strName;}
		void SetIndex(int nIndex) { m_nIndex = nIndex;}
		int  GetIndex() { return m_nIndex;}
		virtual void Init(CVaribleInfo& refVarInfo)
		{
			m_strName = refVarInfo.GetName();
			m_nIndex = refVarInfo.GetIndex();
		}
	protected:
		std::string m_strName;                       //变量名字
		int     m_nIndex;                        //变量序号 
	};

	///////////////////////////////////////////////////////////////////
	//整形变量计算元素基类
	class CIntVaribleFactor
		: public CVaribleFactor
		, public CIntFactor
	{
	public:
		CIntVaribleFactor(std::string strName,int nIndex)
			: CVaribleFactor(strName,nIndex)
		{}
	public:
		virtual void SetValue( int& Val) { m_nValue = Val; }
		virtual CFactor* Evaluate(CContext* objContext)	
		{
			CIDEVariant varValue;
			objContext->GetVariableValue(m_nIndex,varValue);
			m_nValue = varValue;
			return this;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("%s\n",m_strName);
		}	
#endif
	};

	///////////////////////////////////////////////////////////////////
	//浮点数变量计算元素基类
	class CFloatVaribleFactor
		: public CVaribleFactor
		, public CFloatFactor
	{
	public:
		CFloatVaribleFactor(std::string strName,int nIndex)
			: CVaribleFactor(strName,nIndex)	
		{}
	public:
		virtual void SetValue( float& Val)
		{ m_nValue = Val; }
		virtual CFactor* Evaluate(CContext* objContext)	
		{
			CIDEVariant varValue;
			objContext->GetVariableValue(m_nIndex,varValue);
			m_nValue = varValue;
			return this;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("%s\n",m_strName);
		}	
#endif
	};

	///////////////////////////////////////////////////////////////////
	//字符串变量计算元素基类
	class CStringVaribleFactor
		: public CVaribleFactor
		, public CStringFactor
	{
	public:
		CStringVaribleFactor(std::string strName,int nIndex)
			: CVaribleFactor(strName,nIndex)	
		{}
	public:
		virtual void SetValue( std::string& Val)
		{ m_strValue = Val; }
		virtual CFactor* Evaluate(CContext* objContext)	
		{
			CIDEVariant varValue;
			objContext->GetVariableValue(m_nIndex,varValue);
			varValue.ConvertToStr(m_strValue);
			return this;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("%s\n",m_strName);
		}	
#endif
	};

	///////////////////////////////////////////////////////////////////
	//"GetProtocol"函数调用计算元素基类
	class CGetProtocolFactor	
		: public CIntFactor
	{
	public:
		CGetProtocolFactor(std::string strName)
			: m_nProtocolIdx(0)
		{
			Init(strName);
		}
	public:	
		virtual CFactor* Evaluate(CContext* objContext)	
		{
			objContext->Call(TT_PROTOCOLFUN,m_nValue,1,m_nProtocolIdx);
			return this;
		}

	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("%s\n",m_strFuncName);
		}	
#endif
	public:
		void Init(std::string strCallInfo)
		{
			int     nState   = 0;
			char  cCurChar; 
			std::string strTmp;

			for(size_t i = 0;i < strCallInfo.size();i++)
			{
				cCurChar = strCallInfo.at(i);
				switch(nState)
				{
				case 0:
					if(char('(') == cCurChar)
					{
						nState = 1;
						m_strFuncName = strTmp;
						strTmp = ("");
						break;
					}
					strTmp += cCurChar;
					break;
				case 1:
					if(char(')') == cCurChar)
					{				
						m_nProtocolIdx = std::stoi(strTmp);
						strTmp = ("");					
					}
					strTmp += cCurChar;
					break;	
				};
			}
		}
	private:
		std::string m_strFuncName;
		int    m_nProtocolIdx;
	};

	///////////////////////////////////////////////////////////////////
	//"MatchNode"函数调用计算元素基类
	class CGetNodeInfoFactor
		: public CTreeNode
	{
	public:
		CGetNodeInfoFactor(std::string strName)
			: m_strFuncName("")
			, m_nNodeIdx(0)	
			, m_bValue(false)
		{
			Init(strName);
		}
	public:		
		virtual bool Evaluate(CContext* objContext)	
		{
			int64_t nResult = 0;
			objContext->Call(TT_NODFUN,nResult,1,m_nNodeIdx);

			m_bValue = (bool)nResult;
			return m_bValue;
		}

	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("%s\n",m_strFuncName);
		}	
#endif
	public:
		void Init(std::string strCallInfo)
		{
			int     nState   = 0;
			char  cCurChar; 
			std::string strTmp("");

			for(size_t i = 0;i < strCallInfo.size();i++)
			{
				cCurChar = strCallInfo.at(i);
				switch(nState)
				{
				case 0:
					if(char('(') == cCurChar)
					{
						nState = 1;
						m_strFuncName = strTmp;
						strTmp = ("");
						break;
					}
					strTmp += cCurChar;
					break;			
				case 1:
					if(char(')') == cCurChar)
					{	
						m_nNodeIdx = std::stoi(strTmp);								
						break;
					}
					strTmp += cCurChar;
					break;
				};
			}
		}
	private:
		std::string m_strFuncName;
		int    m_nNodeIdx;
		bool    m_bValue;
	};

	///////////////////////////////////////////////////////////////
	//操作基类
	class COperator : public CExpression
	{
	public:
		COperator()		
		{
		}
	};


	///////////////////////////////////////////////////////////////
	//加法操作类
	class CAdditive : public COperator
	{
	public:
		CAdditive()
		{}
	public:
		virtual CFactor* Evaluate(CContext* objContext)	
		{		
			CFactor* pResult = nullptr;	

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{			
				pResult  = *(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext)) 
					+ dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext);			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return pResult;
		}  
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("+\n");
		}	
#endif
	};
	///////////////////////////////////////////////////////////////
	//减法操作类
	class CSubtract : public COperator
	{
	public:
		CSubtract()
		{}
	public:
		virtual CFactor* Evaluate(CContext* objContext)	
		{		
			CFactor* pResult = nullptr;

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{
				pResult  = *(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext))
					- dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext);			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return pResult;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("-\n");
		}	
#endif
	};
	///////////////////////////////////////////////////////////////
	//乘法操作类
	class CMultiply : public COperator
	{
	public:
		CMultiply()
		{}
	public:
		virtual CFactor* Evaluate(CContext* objContext)	
		{		
			CFactor* pResult = nullptr;

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{			
				pResult  = *(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext)) 
					* dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext);			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return pResult;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("*\n");
		}	
#endif
	};
	///////////////////////////////////////////////////////////////
	//除法操作类
	class CDivide : public COperator
	{
	public:
		CDivide()
		{}
	public:
		virtual CFactor* Evaluate(CContext* objContext)	
		{		
			CFactor* pResult = nullptr;

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{			
				pResult  = *(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext)) 
					/ dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext);			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return pResult;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("/\n");
		}	
#endif
	};

	///////////////////////////////////////////////////////////////
	//位与操作类
	class CBitwiseAND : public COperator
	{
	public:
		CBitwiseAND()
		{}
	public:
		virtual CFactor* Evaluate(CContext* objContext)	
		{		
			CFactor* pResult = nullptr;

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{			
				pResult  = *(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext)) 
					& dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext);			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return pResult;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("&\n");
		}	
#endif
	};

	///////////////////////////////////////////////////////////////
	//位异或操作类
	class CBitwiseExclusiveOR : public COperator
	{
	public:
		CBitwiseExclusiveOR()
		{}
	public:
		virtual CFactor* Evaluate(CContext* objContext)	
		{		
			CFactor* pResult = nullptr;

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{			
				pResult  = *(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext)) ^ 
					dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext);			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return pResult;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("^\n");
		}	
#endif
	};

	///////////////////////////////////////////////////////////////
	//位异或操作类
	class CBitwiseOR : public COperator
	{
	public:
		CBitwiseOR()
		{}
	public:
		virtual CFactor* Evaluate(CContext* objContext)	
		{		
			CFactor* pResult = nullptr;

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{			
				pResult  = *(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext)) | 
					dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext);			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return pResult;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("|\n");
		}	
#endif
	};

	//////////////////////////////////////////////////////////////
	//条件表达式基类

	class CCondition
		: public CTreeNode
	{
	public:
		CCondition()
		{
		}	
	public:
		virtual bool Evaluate(CContext* objContext) = 0;
	};

	class CCompare:public CCondition
	{
	public:
		CCompare()	
		{
		}
	};

	class CCompareMore:public CCompare
	{
	public:
		CCompareMore()
		{}
	public:
		virtual bool Evaluate(CContext* objContext)	
		{		
			bool bResult = false;		

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{
				bResult  = *(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext)) >
					dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext);			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return bResult;
		} 
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG(">\n");
		}	
#endif
	};

	class CCompareLess:public CCompare
	{
	public:
		CCompareLess()
		{}
	public:
		virtual bool Evaluate(CContext* objContext)	
		{		
			bool bResult = false;		

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{
				bResult  = *(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext)) <
					dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext);			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return bResult;
		} 
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("<\n");
		}	
#endif
	};

	class CCompareEqual:public CCompare
	{
	public:
		CCompareEqual()
		{}
	public:
		virtual bool Evaluate(CContext* objContext)	
		{		
			bool bResult = false;		

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{
				bResult  = *(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext)) ==
					dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext);			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return bResult;
		} 
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("=\n");
		}	
#endif
	};

	class CCompareUnequal:public CCompare
	{
	public:
		CCompareUnequal()
		{}
	public:
		virtual bool Evaluate(CContext* objContext)	
		{		
			bool bResult = false;		

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{
				bResult  = !(*(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext)) ==
					dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext));			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return bResult;
		} 
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("!=\n");
		}	
#endif
	};

	class CCompareMoreEqual:public CCompare
	{
	public:
		CCompareMoreEqual()
		{}
	public:
		virtual bool Evaluate(CContext* objContext)	
		{		
			bool bResult = false;		

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{
				bResult  = *(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext)) >=
					dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext);			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return bResult;
		} 
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG(">=\n");
		}	
#endif
	};



	class CCompareLessEqual:public CCompare
	{
	public:
		CCompareLessEqual()
		{}
	public:
		virtual bool Evaluate(CContext* objContext)	
		{		
			bool bResult = false;		

			if(nullptr != m_pLeft &&	nullptr != m_pRight)
			{
				bResult  = *(dynamic_cast<CExpression*>(m_pLeft)->Evaluate(objContext)) <=
					dynamic_cast<CExpression*>(m_pRight)->Evaluate(objContext);			
			}
			else
			{
				LOG_DEBUG("错误的表达式，计算失败!\n");
			}
			return bResult;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("<=\n");
		}	
#endif
	};

	class CConj:public CCondition
	{
	public:
		CConj()
		{}

	};

	class CConjOR:public CConj
	{
	public:
		CConjOR()
		{}
	public:
		virtual bool Evaluate(CContext* objContext)	
		{		
			bool bResult = false;

			if(nullptr != m_pLeft && nullptr != m_pRight)
			{
				bResult  = dynamic_cast<CCondition*>(m_pLeft)->Evaluate(objContext) 
					|| dynamic_cast<CCondition*>(m_pRight)->Evaluate(objContext);
			}
			else
			{	
				LOG_DEBUG("在类CConjOR内数据类型转换错误!\n");
			}		
			return bResult;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("||\n");
		}	
#endif
	};

	class CConjAND:public CConj
	{
	public:
		CConjAND()
		{}
	public:
		virtual bool Evaluate(CContext* objContext)	
		{		
			bool bResult = false;

			if(nullptr != m_pLeft && nullptr != m_pRight)
			{
				bResult  = dynamic_cast<CCondition*>(m_pLeft)->Evaluate(objContext) 
					&& dynamic_cast<CCondition*>(m_pRight)->Evaluate(objContext);
			}
			else
			{	
				LOG_DEBUG("在类Evaluate内数据类型转换错误!\n");
			}
			return bResult;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("&&\n");
		}	
#endif
	};

	class CConjNOT:public CConj
	{		
	public:
		CConjNOT()	
		{}
	public:
		virtual bool Evaluate(CContext* objContext)	
		{		
			bool bResult = false;

			if(nullptr != m_pRight)
			{
				bResult  = !(dynamic_cast<CCondition*>(m_pRight)->Evaluate(objContext));			
			}
			else
			{	
				LOG_DEBUG("在类CConjNOT内数据类型转换错误!\n");
			}
			return bResult;
		}
	public:
#ifdef _DEBUG
		virtual void ShowNoe()
		{
			CTreeNode::ShowNoe();
			LOG_DEBUG("!\n");
		}	
#endif
	};


	class CTokenInfo
	{
	public:
		CTokenInfo()
			: m_ttType(TT_ERR)	
			, m_strValue("")
		{
		}
		void SetType(CSTOKEN_TYPE ttType) { m_ttType = ttType;}
		CSTOKEN_TYPE GetType() { return m_ttType;}

		void SetValue(std::string strValue) { m_strValue = strValue;}
		std::string GetValueAsString() { return m_strValue;}
		float  GetValueAsFloat() 
		{
			return (float)std::stof(m_strValue); 
		}
		int64_t  GetValueAsInt() 
		{
			return  std::stoll(m_strValue); 
		}

	private:
		CSTOKEN_TYPE m_ttType;               //符号类型
		std::string      m_strValue;             //值　　　　
	};

	class CKeywordHash
	{
	public:
		size_t operator()(const std::string& _Keyval) const
		{
			size_t nHash = 0;

			for (size_t i = 0; i < _Keyval.size(); i++)
			{
				nHash = (nHash << 5) + nHash + _Keyval.at(i);
			}

			return nHash;
		}
	};
	
	class CKeywordEqual
	{
	public:
		bool operator()(const std::string& _Keyval1, const std::string& _Keyval2) const
		{
			const bool bResult = (_Keyval1 == _Keyval2);		

			return bResult;
		}	
		
	};

	using CReservedKeywordMap = std::unordered_map<std::string, CSTOKEN_TYPE, CKeywordHash, CKeywordEqual>;


	class CCalcLogicForm
	{
	public:
		CCalcLogicForm(void);
		~CCalcLogicForm(void);
	public:
		std::string GetLogicForm() { return m_strLogicForm;}
	public:
		bool AddVarible(std::string& strName,CSTOKEN_TYPE m_dtType,int nIndex);
		bool LookUpVarible(std::string strName,CVaribleInfo& objResult);
		void EmptyVarible();
		bool AnalyseExpression(std::string& strExpression);		
		bool Calculate(CContext* objContext);
	protected:	
		CTreeNode* AnalyseOR();
		CTreeNode* AnalyseAND();
		CTreeNode* AnalyseBitwiseOR();
		CTreeNode* AnalyseBitwiseExcOR();
		CTreeNode* AnalyseBitwiseAND();
		CTreeNode* AnalyseCompare();
		CTreeNode* AdditiveExpression();
		CTreeNode* Term();
		CTreeNode* ThirdExpression();		
		CTreeNode* Factor();
	protected:	
		CTreeNode* CreateTreeNode(size_t nTokenIndex);
		CTreeNode* LookforTreeNode(CSTOKEN_TYPE ttTokenType);

		void EmptyTreeNodePool();
		void DestroyTree();
	protected:	                                //特列函数
		std::string  IPConvert(std::string& strIpInfo);
		std::string  MacConvert(std::string& strMacInfo);
		int64_t HexToDec(std::string& strHex);
	protected:	
		bool ScanToken(std::string& strExpression);
		bool CreateSyntaxTree();
		void FormatLogicFml(std::string& beFmtLogFml);
		bool IsDigital(const char nChar);
		bool IsCharacter(const char nChar);
		bool CheckRepeatIndex(int nIndex);
		CSTOKEN_TYPE LookupReserverKeyword(std::string& strString);
		void InitReservedKeywordHashMap(void);
	protected:
		CTreeNode*                     m_pTreeRoot;
		size_t                         m_nCurTokenIndex;
		std::string                        m_strLogicForm;	
		std::map<std::string,CVaribleInfo> m_mapVaribleInfo;      //关键字列表
		std::vector<CTokenInfo>        m_aryToken;            //符号列表
		std::vector<CTreeNode*>        m_aryTreeNodePool;     //分析树节点池	
		bool                           m_bAvailabilitySyntaxTree;//当前的语法分析树是否有效
		CReservedKeywordMap      m_hmReservedKeyword;
	}; 
}
