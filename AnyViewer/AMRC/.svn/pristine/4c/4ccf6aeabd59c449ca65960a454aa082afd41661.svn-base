#include "stdafx.h"
#include "Application.h"
#include <sys/wait.h>
#include <sys/prctl.h>
#include <signal.h>
#include <iostream>

#include <unistd.h>


CModuleStat g_moduleState;

CApplication* GetTheApp()
{
    return g_moduleState.m_pCurrentWinApp;
}

CApplication::CApplication(const char* lpLogFile,const char* lpConfigFile)
	: m_objConfig(lpConfigFile)
{
    GetAppPath(m_strLogFile);
    m_strLogFile += lpLogFile;
   
    g_moduleState.m_pCurrentWinApp = this;
}

// --------------------------------------------------------------------------------
/// <summary>
/// 得到当前应用程序运行路径
/// </summary>
/// <param name="refPath">程序运行路径</param>
/// <created>黄丽云,2019/1/19</created>
/// <changed>黄丽云,2019/1/19</changed>
// --------------------------------------------------------------------------------
void CApplication::GetAppPath(std::string & refPath)
{
	char szPathBuffer[PATH_MAX] = { 0 };
	getcwd(szPathBuffer, PATH_MAX);

	refPath = szPathBuffer;
}

void CApplication::Execute()
{
    Init();
    LOG_INFO("Start the Sever App...");
	//ExecuteChildProcess();

#if DEBUG
    ExecuteChildProcess();
#else
    //fork一个进程
    pid_t fPid = fork();
    if (fPid < 0)
    {
        exit(-1);
    }

    if (fPid > 0)
    {
        while (true)
        {
            int nStatus = 0;
            pid_t fWaitId = wait(&nStatus);

            //信号退出
            if (WIFSIGNALED(nStatus))
            {
                LOG_DEBUG("child process signal exit");
                int signal_num = WTERMSIG(nStatus);
                if (SIGKILL == signal_num)
                {
                    break;
                }
            }
            else if (WIFEXITED(nStatus))
            {
                //正常退出
                int nExitStatus = WEXITSTATUS(nStatus);
                LOG_DEBUG("child process nomal exit:%d", nExitStatus);
                break;
            }

            fPid = fork();
            if (0 == fPid)
            {
                ExecuteChildProcess();
            }
        }
    }
    else
    {
        ExecuteChildProcess();
    }
#endif

	LOG_INFO("The Sever App has exited.");
}

// ********************************************************************************
/// <summary>
/// 执行子进程
/// </summary>
/// <created>Leiyz,2019/9/8</created>
/// <changed>Leiyz,2019/9/8</changed>
// ********************************************************************************
void CApplication::ExecuteChildProcess()
{
    //父进程退出的时候，将通知子进程
    prctl(PR_SET_PDEATHSIG, SIGKILL);
    printf("child pid=%d\n", getpid());
    
	const bool bSeccuss = OnInit();
	
	if (bSeccuss)
	{
		Run();	
	}
    
}

// --------------------------------------------------------------------------------
/// <summary>
/// 初始化应用程序
/// </summary>
/// <returns></returns>
/// <created>黄丽云,2019/1/19</created>
/// <changed>黄丽云,2019/1/19</changed>
// --------------------------------------------------------------------------------
bool CApplication::Init()
{
    RegisterSignals();

	std::string strPath;

	GetAppPath(strPath);

    const bool bResult = m_objConfig.Read();

	if (!bResult)
	{
		LOG_DEBUG("Fail to open config file '%s'!", m_strLogFile.c_str());
	}

    std::string strLogLevel = m_objConfig.GetValue("logLevel", "all");
    std::string strSize = m_objConfig.GetValue("logMaxSize", "10");
    uint64_t nRotateSize = atoll(strSize.c_str()) * 1024 * 1024;

	CLoggerHelper::Instance()->Open(
		m_strLogFile.c_str()
		, CLogger::QueryLevel(strLogLevel.c_str())
		, nRotateSize);

    return bResult;
}

void CApplication::SignalHandler(int nSig)
{
    std::string strSig;
    switch (nSig)
    {
		case SIGTERM:
            strSig = "SIGTERM";
            break;
        case SIGINT:
            strSig = "SIGINT";
            break;
        case SIGSEGV:
            strSig = "SIGSEGV";
            break;
        case SIGBUS:
            strSig = "SIGBUS";
            break;
        default:
            strSig = "UNKNOW";
    }
 
    LOG_WARN("catch signal:%d type:%s", nSig, strSig.c_str());
    exit(-1);
    //GetTheApp()->OnUninitialized();   
}

void CApplication::RegisterSignals()
{
    struct sigaction sa;

    bzero(&sa, sizeof(sa));
	sa.sa_handler = SIG_IGN;
    sigaction(SIGPIPE, &sa, 0);
    signal(SIGTERM, SignalHandler);
    signal(SIGINT, SignalHandler);
    //signal(SIGSEGV, SignalHandler);
    signal(SIGBUS, SignalHandler);

	sigset_t signal_mask;
	sigemptyset(&signal_mask);
	sigaddset(&signal_mask, SIGPIPE);

	int rc = pthread_sigmask(SIG_BLOCK, &signal_mask, nullptr);

	if (rc != 0)
	{
		printf("block sigpipe error/n");
	}
}



std::string CApplication::GetValue(const std::string & strKey, const std::string & strDefault)
{
	return m_objConfig.GetValue(strKey, strDefault);
}

int CApplication::GetValue(const std::string & strKey, const int nDefault)
{
	return m_objConfig.GetValue(strKey, nDefault);
}

void CApplication::SetValue(const std::string & strKey, const std::string & strValue)
{
	m_objConfig.SetValue(strKey, strValue);
}


void CApplication::OnUninitialized()
{
	m_objConfig.Write();
    exit(0);
}