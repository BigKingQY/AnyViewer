///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  
/// @brief 数据流传输助手定义
/// 
/// 实现了收发数据流的功能 
/// @author 黄丽云
/// @version 1.0
/// @date        2020-3-29
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once
#include "TransactionManager.h"
#include "StreamTransAbstract.h"
#include "DataPacket.h"

#define TRANSFER_STREAM_TIMEOUT  60 * 60 ///< 传输流的最大超时(4小时)
#define PACKET_PAYLOAD_LEN_MAX  1024 * 8 ///< 数据包的最大长度

class CDataPacket;

template <class T,class EndpointT>
class CTransactionServiceT :public T
{
public:
	CTransactionServiceT();
	virtual ~CTransactionServiceT();

public:

	// 初始化文件流
	bool InitFileStream(const char* szPath, CFileStreamTransPtr pFileStream);

	// 请求传输数据流
	bool RequestStreamTransfer(EndpointT pEndpoint, const U32 nPacketID, const U64 nTransID, const U16 nType, const std::string strMD5, const U64 nSize, const bool bQuickMode = false);

	// 应答数据流传输请求
	bool ResponseStreamTransfer(EndpointT pEndpoint, CStreamTransAbstractPtr  pTrans, CDataPacket * pDataPacket);

	// 请求终止数据流传输
	bool RequestAbortingStreamTransfer(EndpointT pEndpoint, const U64 nTransId);

	// 发送一个通用应答数据包
	bool SendCommonResponse(EndpointT pEndpoint, CDataPacket* pDataPacket, I32 nFlag, U64 nStatus = 0);

	// 于服务器同步流事物数据
	void RequestSynStreamTrans(EndpointT pEndpoint, CStreamTransAbstractPtr pStreamTrans);

	// 查找事务
	CTransAbstractPtr LookupTrans(U64 nID);

	// 发送文件
	bool Send(EndpointT pEndpoint,const U32 nID, const U32 nType,const U8* pData, const U32 nLen, const bool bQuickMode = false);

	// 发送文件
	bool SendFile(EndpointT pEndpoint, const U32 nID, const U32 nType, const char* lpFile, const bool bQuickMode = false);

	// 采用流发送一个对象
	template<class TJsonObj>
	bool SendJsonObj(EndpointT pEndpoint, const U32 nID, const U32 nType,const TJsonObj& refJsonObj)
	{
		bool bResult = false;
		CMemoryStreamTransPtr pStream = std::dynamic_pointer_cast<CMemoryStreamTrans>(CreateTrans(
			nID
			, nType
			, TRANSFER_STREAM_TIMEOUT));

		if (nullptr != pStream)
		{
			pStream->InjectJsonObjT<TJsonObj>(refJsonObj);
			bResult = RequestStreamTransfer(
				pEndpoint
				, GetMsgId()
				, pStream->GetID()
				, nType
				, pStream->CalcMd5()
				, pStream->GetLength());	
		}

		return bResult;
	}
protected:
	bool OnStreamHandle(EndpointT pEndpoint, CDataPacket* pDataPacket);

protected:
	// 处理传输数据流请求
	virtual CStreamTransAbstractPtr OnTransferStreamRequest(EndpointT pEndpoint, CDataPacket* pDataPacket);

	// 处理传输数据流应答
	virtual void OnTransferStreamResponse(EndpointT pEndpoint, CDataPacket * pDataPacket);

	// 处理传输数据流数据块请求
	virtual void OnTransferStreamDataRequest(EndpointT pEndpoint, CDataPacket* pDataPacket);

	// 处理传输数据流数据块应答
	virtual void OnTransferStreamDataResponse(EndpointT pEndpoint, CDataPacket * pDataPacket);

	// 处理移动流偏移请求
	virtual void OnMoveStreamOffsetRequest(EndpointT pEndpoint, CDataPacket * pDataPacket);

	// 处理移动流偏移应答
	virtual void OnMoveStreamOffsetResponse(EndpointT pEndpoint, CDataPacket * pDataPacket);

	// 处理终止传输数据流请求
	virtual void OnAbortTransferStreamRequest(EndpointT pEndpoint, CDataPacket * pDataPacket);

	// 处理数据流同步请求
	virtual void OnSynStreamRequest(EndpointT pEndpoint, CDataPacket* pDataPacket);

protected:
	// 数据流传输完毕事件
	virtual void OnTransferStreamOver(bool bSending, CStreamTransAbstractPtr pTrans);

	// 创建一个流传输对象
	virtual CTransAbstractPtr CreateTrans(const U64 nID, const U32 nType, const U32 nExpires = 0);

	// 删除一个事物
	virtual void RemoveTrans(CTransAbstractPtr pTrans);
protected:

	CTransManager              m_objTransManager;
};


template <class T, class EndpointT>
inline CTransactionServiceT<T, EndpointT>::CTransactionServiceT()
{
}

template <class T, class EndpointT>
inline CTransactionServiceT<T, EndpointT>::~CTransactionServiceT()
{
}


//--------------------------------------------------------------------------------
/// <summary>
/// 初始化文件流
/// </summary>
/// <param name="lpName">文件名称</param>
/// <param name="pFileStream">指向文件流对象的指针</param>
/// <returns>true:成功,false:失败</returns>
/// <created>Andy,2020/1/2</created>
/// <changed>Andy,2020/1/2</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline bool CTransactionServiceT<T, EndpointT>::InitFileStream(
	const char* szPath
	, CFileStreamTransPtr pFileStream)
{
	bool bResult = false;

	if (nullptr != pFileStream)
	{
		boost::filesystem::path objPath(szPath);


		if (!boost::filesystem::exists(objPath))
		{
			boost::filesystem::create_directories(objPath);
		}

		//objPath /= (CString(lpName));

		if (!pFileStream->Open(objPath.string(), false))
		{
			bResult = true;
		}
	}

	return bResult;
}

//--------------------------------------------------------------------------------
/// <summary>
/// 请求传输数据流
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="nPacketID">应答数据包ID</param>
/// <param name="nTransID">流id</param>
/// <param name="nType">流的类型</param>
/// <param name="lpMD5">流的md5值</param>
/// <param name="nSize">流的大小</param>
/// <returns></returns>
/// <created>Andy,2020/3/27</created>
/// <changed>Andy,2020/3/27</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline bool CTransactionServiceT<T, EndpointT>::RequestStreamTransfer(
	EndpointT pEndpoint
	, const U32 nPacketID
	, const U64 nTransID
	, const U16 nType
	, const std::string strMD5
	, const U64 nSize
	, const bool bQuickMode)
{
	CDataPacket objRequestPacket;

	objRequestPacket.InitialT<TRANSFER_STREAM_REQUEST>(
		nPacketID, MT_TRANSFER_STREAM, OT_REQUEST);

	TRANSFER_STREAM_REQUEST* pTransferStreamPacket = (TRANSFER_STREAM_REQUEST*)objRequestPacket.GetHeaderPtr();

	pTransferStreamPacket->nType = HTONS(nType);
	pTransferStreamPacket->nId = NTOHQ(nTransID);
	memcpy(pTransferStreamPacket->szMd5, strMD5.c_str(), 32);
	pTransferStreamPacket->szMd5[MD5_LEN_MAX] = 0;
	pTransferStreamPacket->nSize = NTOHQ(nSize);
	pTransferStreamPacket->bQuickMode = bQuickMode;

	const bool bResult = pEndpoint->Send(&objRequestPacket);

	return bResult;
}

//--------------------------------------------------------------------------------
/// <summary>
/// 发送传输流应答
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="pTransAbstract">指向一个事务对象的指针</param>
/// <param name="pDataPacket">指向当前数据包对象的指针</param>
/// <returns>true:成功,false:失败</returns>
/// <created>Andy,2020/3/27</created>
/// <changed>Andy,2020/3/27</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline bool CTransactionServiceT<T, EndpointT>::ResponseStreamTransfer(
	EndpointT pEndpoint
	, CStreamTransAbstractPtr pTransAbstract
	, CDataPacket* pDataPacket)
{
	U64 nStatusCode = 0;   ///< 返回响应结果状态码

	if (!pTransAbstract)
	{
		nStatusCode = ES_ALLOCATE_TRANS_UNSUCCESSFULLY;
	}

	CDataPacket objResponsePacket;

	objResponsePacket.InitialT<TRANSFER_STREAM_RESPONSE>(
		pDataPacket->GetPacketId()
		, (WORD)pDataPacket->GetPacketType()
		, BYTE(OT_RESPONSE | ((0 == nStatusCode) ? OR_SUCCESS : OR_FAILURE)));

	if (nullptr != pTransAbstract)
	{
		TRANSFER_STREAM_REQUEST* pRequest = (TRANSFER_STREAM_REQUEST*)pDataPacket->GetBuffer();
		TRANSFER_STREAM_RESPONSE* pResponsePacket = (TRANSFER_STREAM_RESPONSE*)objResponsePacket.GetHeaderPtr();

		pResponsePacket->nId = pRequest->nId;    ///< 本身是网络字节序号
		pResponsePacket->nStatusCode = (U32)NTOHQ(nStatusCode);
	}

	const bool bResult = pEndpoint->Send(&objResponsePacket);

	return bResult;
}


//--------------------------------------------------------------------------------
/// <summary>
/// 终止流事务
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="nTransId">被终止流事务ID</param>
/// <returns>true:成功,false:失败</returns>
/// <created>Andy,2020/3/27</created>
/// <changed>Andy,2020/3/27</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline bool CTransactionServiceT<T, EndpointT>::RequestAbortingStreamTransfer(
	EndpointT pEndpoint,
	const U64 nTransId)
{
	CDataPacket objRequestPacket;

	objRequestPacket.InitialT<ABORT_TRANSFER_STREAM_REQUEST>(
		GetMsgId()
		, MT_ABORT_TRANSFER_STREAM
		, OT_REQUEST
		, 0);

	ABORT_TRANSFER_STREAM_REQUEST* pTransferRequest =
		(ABORT_TRANSFER_STREAM_REQUEST*)objRequestPacket.GetHeaderPtr();

	pTransferRequest->nId = NTOHQ(nTransId);
	bool bResult = pEndpoint->Send(&objRequestPacket);

	return bResult;
}


//--------------------------------------------------------------------------------
/// <summary>
/// 发送一个通用应答数据包
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="pDataPacket">指向当前数据包对象的指针</param>
/// <param name="nFlag">标志</param>
/// <param name="nStatus">状态</param>
/// <returns>true:成功,false:失败</returns>
/// <created>Andy,2020/3/27</created>
/// <changed>Andy,2020/3/27</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline bool CTransactionServiceT<T, EndpointT>::SendCommonResponse(
	EndpointT pEndpoint
	, CDataPacket* pDataPacket
	, I32 nFlag
	, U64 nStatus)
{
	CDataPacket objResponsePacket;
	objResponsePacket.InitialT<COMMON_RESPONSE>(
		pDataPacket->GetPacketId()
		, (WORD)pDataPacket->GetPacketType()
		, BYTE(OT_RESPONSE | nFlag));

	COMMON_RESPONSE* pResponsePacket = (COMMON_RESPONSE*)objResponsePacket.GetHeaderPtr();
	pResponsePacket->nStatusCode = NTOHQ(nStatus);

	return pEndpoint->Send(&objResponsePacket);
}


//--------------------------------------------------------------------------------
/// <summary>
/// 于服务器同步流事物数据
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="pStreamTrans"></param>
/// <created>Andy,2020/3/27</created>
/// <changed>Andy,2020/3/27</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline void CTransactionServiceT<T, EndpointT>::RequestSynStreamTrans(
	EndpointT pEndpoint
	, CStreamTransAbstractPtr pStreamTrans)
{
	CHECK_POINTER(pStreamTrans);

	// 把事务重新加入事务管理器,因为收到后被删除了
	m_objTransManager.Append(pStreamTrans);

	CDataPacket objRequestPacket;

	objRequestPacket.InitialT<SYN_STREAM_REQUEST>(
		GetMsgId(), MT_SYN_STREAM, OT_REQUEST);

	SYN_STREAM_REQUEST* pTransferStreamPacket = (SYN_STREAM_REQUEST*)objRequestPacket.GetHeaderPtr();

	pTransferStreamPacket->nType = HTONS((U16)pStreamTrans->GetType());
	pTransferStreamPacket->nId = NTOHQ(pStreamTrans->GetID());
	memcpy(pTransferStreamPacket->szMd5, pStreamTrans->CalcMd5().c_str(), 32);
	pTransferStreamPacket->szMd5[MD5_LEN_MAX] = 0;
	pTransferStreamPacket->nSize = NTOHQ(pStreamTrans->GetLength());

	pEndpoint->Send(&objRequestPacket);
}


//--------------------------------------------------------------------------------
/// <summary>
/// 查找事务
/// </summary>
/// <param name="nID">事务ID</param>
/// <returns>成功返回指向事务对象的指针,否则null</returns>
/// <created>Andy,2020/3/28</created>
/// <changed>Andy,2020/3/28</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline CTransAbstractPtr CTransactionServiceT<T, EndpointT>::LookupTrans(U64 nID)
{
	return m_objTransManager.Lookup(nID);
}


// ********************************************************************************
/// <summary>
/// 同步发送
/// </summary>
/// <param name="pEndpoint">需要发送数据的端点</param>
/// <param name="nID">事物ID（确保整个系统唯一）</param>
/// <param name="nType">事务类型</param>
/// <param name="pData">指向被发送数据的指针</param>
/// <param name="nLen">需要发送数据的长度</param>
/// <param name="bQuickMode">true:快速模式，false:可靠模式</param>
/// <returns></returns>
/// <created>Andy,2021/1/21</created>
/// <changed>Andy,2021/1/21</changed>
// ********************************************************************************
template<class T, class EndpointT>
inline bool CTransactionServiceT<T, EndpointT>::Send(
	EndpointT pEndpoint
	, const U32 nID
	, const U32 nType
	, const U8 * pData
	, const U32 nLen
	, const bool bQuickMode)
{
	bool bResult = false;
	CMemoryStreamTransPtr pStream = std::dynamic_pointer_cast<CMemoryStreamTrans>(CreateTrans(
		nID
		, nType
		, TRANSFER_STREAM_TIMEOUT));

	if (nullptr != pStream)
	{
		pStream->SetQuickMode(bQuickMode);
		pStream->SetLength(nLen);
		pStream->Write(pData, nLen);

		bResult = RequestStreamTransfer(
			pEndpoint
			, GetMsgId()
			, pStream->GetID()
			, U16(nType)
			, ""
			, pStream->GetLength()
			, bQuickMode);
	}

	return bResult;
}

//--------------------------------------------------------------------------------
/// <summary>
/// 发送文件
/// </summary>
/// <param name="nID">事物ID（确保整个系统唯一）</param>
/// <param name="nType">类型</param>
/// <param name="lpFile">文件路径</param>
/// <returns></returns>
/// <created>Andy,2020/8/28</created>
/// <changed>Andy,2020/8/28</changed>
//--------------------------------------------------------------------------------
template<class T, class EndpointT>
inline bool CTransactionServiceT<T, EndpointT>::SendFile(
	EndpointT pEndpoint
	, const U32 nID
	, const U32 nType
	, const char* lpFile
	, const bool bQuickMode)
{
	bool bResult = false;
	CFileStreamTransPtr pStream = std::dynamic_pointer_cast<CFileStreamTrans>(CreateTrans(
		nID
		, nType
		, TRANSFER_STREAM_TIMEOUT));

	if (nullptr != pStream)
	{
		const bool bSuccess = pStream->Open(lpFile);

		if (bSuccess)
		{
			bResult = RequestStreamTransfer(
				pEndpoint
				, GetMsgId()
				, pStream->GetID()
				, nType
				, pStream->CalcMd5()
				, pStream->GetLength()
				, bQuickMode);
		}
	}


	return bResult;
}

//--------------------------------------------------------------------------------
/// <summary>
/// 处理流消息
/// </summary>
/// <param name="pEndpoint">指向一个端点对象的指针</param>
/// <param name="pPacket">指向一个数据包对象的指针</param>
/// <returns></returns>
/// <created>Andy,2020/3/27</created>
/// <changed>Andy,2020/3/27</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline bool CTransactionServiceT<T, EndpointT>::OnStreamHandle(
	EndpointT pEndpoint
	, CDataPacket* pDataPacket)
{
	bool bResult = true;
	assert(nullptr != pEndpoint && nullptr != pDataPacket);

	//应答包
	const U16 uMsgFlag = (U16)pDataPacket->GetPacketFlag();

	if ((uMsgFlag & OT_RESPONSE) == OT_RESPONSE)
	{
		switch (pDataPacket->GetPacketType())
		{
		case MT_TRANSFER_STREAM:
			OnTransferStreamResponse(pEndpoint, pDataPacket);
			break;

		case MT_TRANSFER_STREAM_DATA:
			OnTransferStreamDataResponse(pEndpoint, pDataPacket);
			break;

		case MT_MOVE_STREAM_OFFSERT:
			OnMoveStreamOffsetResponse(pEndpoint, pDataPacket);
			break;

		default:
			bResult = false;
		}
	}
	else
	{
		//请求包
		switch (pDataPacket->GetPacketType())
		{
		case MT_TRANSFER_STREAM:
			OnTransferStreamRequest(pEndpoint, pDataPacket);
			break;

		case MT_SYN_STREAM:
			OnSynStreamRequest(pEndpoint, pDataPacket);
			break;

		case MT_TRANSFER_STREAM_DATA:
			OnTransferStreamDataRequest(pEndpoint, pDataPacket);
			break;

		case MT_MOVE_STREAM_OFFSERT:
			OnMoveStreamOffsetRequest(pEndpoint, pDataPacket);
			break;

		case MT_ABORT_TRANSFER_STREAM:
			OnAbortTransferStreamRequest(pEndpoint, pDataPacket);
			break;

		default:
			bResult = false;
		}
	}

	return bResult;
}

//--------------------------------------------------------------------------------
/// <summary>
/// 处理传输数据流请求
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="pDataPacket">指向当前数据包对象的指针</param>
/// <created>Andy,2020/3/27</created>
/// <changed>Andy,2020/3/27</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline CStreamTransAbstractPtr CTransactionServiceT<T, EndpointT>::OnTransferStreamRequest(
	EndpointT pEndpoint
	, CDataPacket* pDataPacket)
{
	assert(nullptr != pDataPacket);

	TRANSFER_STREAM_REQUEST* pRequest = (TRANSFER_STREAM_REQUEST*)pDataPacket->GetHeaderPtr();
	CStreamTransAbstractPtr pTransAbstract = std::static_pointer_cast<CStreamTransAbstract>(
		CreateTrans(NTOHQ(pRequest->nId), NTOHS(pRequest->nType), 0));

	if (nullptr != pTransAbstract)
	{
		pTransAbstract->SetOrgLength(NTOHQ(pRequest->nSize));
		pTransAbstract->SetOrgMd5((char*)pRequest->szMd5);
		pTransAbstract->SetQuickMode(pRequest->bQuickMode);

		ResponseStreamTransfer(pEndpoint, pTransAbstract, pDataPacket);
	}
	else
	{

	}

	return pTransAbstract;
}


//--------------------------------------------------------------------------------
/// <summary>
/// 处理数据流传输应答
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="pDataPacket">指向当前数据包对象的指针</param>
/// <created>Andy,2019-03-25</created>
/// <changed>Andy,2019-03-25</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline void CTransactionServiceT<T, EndpointT>::OnTransferStreamResponse(
	EndpointT pEndpoint
	, CDataPacket* pDataPacket)
{
	TRANSFER_STREAM_RESPONSE* pResponsePacket = (TRANSFER_STREAM_RESPONSE*)pDataPacket->GetHeaderPtr();
	CStreamTransAbstractPtr pTrans = std::dynamic_pointer_cast<CStreamTransAbstract>(
		m_objTransManager.Lookup(NTOHQ(pResponsePacket->nId)));

	if (pDataPacket->GetPacketFlag() & OR_SUCCESS)
	{
		if (nullptr != pTrans)
		{
			pTrans->SetStatus(STS_TRANS);
			pTrans->MoveReadingOffset(0);			

			// 下面的代码是发送流数据，考虑了两种情况，快速模式就是不断发送的发送数据，直到发送完毕
			// 普通模式值发送第一段数据，等到接收端收到数据包后再继续发送
			do
			{
				const U32 nDataLen = custom_min(int(pTrans->GetLength()), int(PACKET_PAYLOAD_LEN_MAX));

				if (0 == nDataLen)
				{
					break;
				}

				const int PACKET_ID = GetMsgId();
				CDataPacket objRequestPacket;

				objRequestPacket.InitialT<TRANSFER_STREAM_DATA_REQUEST>(
					PACKET_ID
					, MT_TRANSFER_STREAM_DATA
					, OT_REQUEST
					, nDataLen);

				TRANSFER_STREAM_DATA_REQUEST* pTransferRequest =
					(TRANSFER_STREAM_DATA_REQUEST*)objRequestPacket.GetHeaderPtr();

				pTransferRequest->nId = NTOHQ(pTrans->GetID());
				pTransferRequest->nSize = HTONL(nDataLen);
				pTransferRequest->nOffset = NTOHQ(pTrans->GetReadingOffset());
				pTrans->Read(GetVarDataPtr<TRANSFER_STREAM_DATA_REQUEST>((unsigned char*)pTransferRequest)
					, nDataLen, false);
				pEndpoint->Send(&objRequestPacket);

				if (pTrans->GetQuickMode())
				{
					// 如果是快速模式就直接修改读取位置
					pTrans->MoveReadingOffset(pTrans->GetReadingOffset() + nDataLen);
				}
			
			} while (pTrans->GetQuickMode());

			if (pTrans->GetQuickMode())
			{
				OnTransferStreamOver(true, pTrans);
			}
		}
		else
		{
			SendCommonResponse(pEndpoint, pDataPacket, OR_FAILURE, ES_NOT_FOUND_TRANS);
		}
	}
	else
	{
		// 如果失败直接删除流传输事务
		const U64 nStatusCode = NTOHQ(pResponsePacket->nStatusCode);
		std::cout << "传输流响应失败errCode:" << nStatusCode << std::endl;

		pTrans->SetStatus(STS_FALED);
		RemoveTrans(pTrans);
	}
}




//--------------------------------------------------------------------------------
/// <summary>
/// 处理传输数据流数据块请求
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="pDataPacket">指向当前数据包对象的指针</param>
/// <created>Andy,2019-03-25</created>
/// <changed>Andy,2019-03-25</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline void CTransactionServiceT<T, EndpointT>::OnTransferStreamDataRequest(
	EndpointT pEndpoint
	, CDataPacket* pDataPacket)
{
	assert(nullptr != pDataPacket);

	if (nullptr != pDataPacket)
	{
		U64 nStatusCode = 0;
		TRANSFER_STREAM_DATA_REQUEST* pRequest = (TRANSFER_STREAM_DATA_REQUEST*)pDataPacket->GetHeaderPtr();
		CStreamTransAbstractPtr pTrans = std::dynamic_pointer_cast<CStreamTransAbstract>(
			m_objTransManager.Lookup(NTOHQ(pRequest->nId)));

		if (nullptr != pTrans)
		{
			bool bSuccess = false;

			pTrans->MoveWritingOffset(NTOHQ(pRequest->nOffset));
			pTrans->Write((BYTE*)GetVarDataPtr<TRANSFER_STREAM_DATA_REQUEST>((unsigned char*)pRequest)
				, NTOHL(pRequest->nSize));

			if (pTrans->TransferOver())
			{
				bSuccess = pTrans->IsValid();

				if (!bSuccess)
				{
					pTrans->MoveWritingOffset(0);
					nStatusCode = ES_RETRANSFER;
				}
			}


			if (!pTrans->GetQuickMode())
			{
				// 只有非快速模式才发送应答数据包，发送端收到应答包后才发送一下数据包
				CDataPacket objResponsePacket;

				objResponsePacket.InitialT<TRANSFER_STREAM_DATA_RESPONSE>(
					pDataPacket->GetPacketId()
					, (WORD)pDataPacket->GetPacketType()
					, (BYTE)(OT_RESPONSE | ((0 == nStatusCode) ? OR_SUCCESS : OR_FAILURE)));

				TRANSFER_STREAM_DATA_RESPONSE* pResponsePacket = (TRANSFER_STREAM_DATA_RESPONSE*)objResponsePacket.GetHeaderPtr();

				pResponsePacket->nId = NTOHQ(pTrans->GetID());
				pResponsePacket->nOffset = (0 == nStatusCode) ? NTOHQ(NTOHQ(pRequest->nOffset) + HTONL(pRequest->nSize)) : 0;
				pResponsePacket->nStatusCode = (U32)NTOHQ(nStatusCode);
				pEndpoint->Send(&objResponsePacket);
			}

			if (bSuccess)
			{
				OnTransferStreamOver(true, pTrans);
			}
		}
		else if (nullptr != pTrans)
		{
			// 如果没有找到流事务,那么直接通知对方终止传输
			RequestAbortingStreamTransfer(pEndpoint, NTOHQ(pTrans->GetID()));
		}
	}
}

//--------------------------------------------------------------------------------
/// <summary>
/// 处理数据流块传输应答
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="pDataPacket">指向当前数据包对象的指针</param>
/// <created>Andy,2019-03-25</created>
/// <changed>Andy,2019-03-25</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline void CTransactionServiceT<T, EndpointT>::OnTransferStreamDataResponse(
	EndpointT pEndpoint
	, CDataPacket* pDataPacket)
{
	TRANSFER_STREAM_DATA_RESPONSE* pResponsePacket = (TRANSFER_STREAM_DATA_RESPONSE*)pDataPacket->GetHeaderPtr();
	const U64 TRANS_ID = NTOHQ(pResponsePacket->nId);
	CStreamTransAbstractPtr pTrans = std::dynamic_pointer_cast<CStreamTransAbstract>(
		m_objTransManager.Lookup(TRANS_ID));

	if (nullptr != pTrans)
	{
		if (pDataPacket->GetPacketFlag() & OR_SUCCESS)
		{
			//群发文件时会收到重复应答,所以过滤重复的应答数据包
			const U64 nNewOffset = NTOHQ(pResponsePacket->nOffset);

			if (pTrans->GetReadingOffset() <= nNewOffset)
			{
				pTrans->MoveReadingOffset(nNewOffset);

				const U32 nDataLen = (U32)custom_min(U64(pTrans->GetLength())
					, U64(PACKET_PAYLOAD_LEN_MAX));

				if (nDataLen > 0)
				{
					const int PACKET_ID = GetMsgId();
					CDataPacket objRequestPacket;

					objRequestPacket.InitialT<TRANSFER_STREAM_DATA_REQUEST>(
						PACKET_ID
						, MT_TRANSFER_STREAM_DATA
						, OT_REQUEST
						, (U32)nDataLen);

					TRANSFER_STREAM_DATA_REQUEST* pTransferRequest =
						(TRANSFER_STREAM_DATA_REQUEST*)objRequestPacket.GetHeaderPtr();

					pTransferRequest->nId = NTOHQ(pTrans->GetID());
					pTransferRequest->nSize = HTONL((U32)nDataLen);
					pTransferRequest->nOffset = NTOHQ(pTrans->GetReadingOffset());
					pTrans->Read(
						GetVarDataPtr<TRANSFER_STREAM_DATA_REQUEST>((unsigned char*)pTransferRequest)
						, (U32)nDataLen
						, false);
					pEndpoint->Send(&objRequestPacket);
				}
				else
				{
					pTrans->SetStatus(STS_SUCCESS);
					OnTransferStreamOver(false, pTrans);
				}
			}
			else
			{
				assert(false);
			}
		}
		else
		{
			switch (NTOHQ(pResponsePacket->nStatusCode))
			{
			case ES_NOT_FOUND_TRANS:
			{
				pTrans->SetStatus(STS_FALED);
				RemoveTrans(pTrans);
			}
			break;

			default:
			{
				if (pTrans->GetTryNum() > RETRANSFER_NUMBER_MAX)
				{
					RequestAbortingStreamTransfer(pEndpoint, pTrans->GetID());

					pTrans->SetStatus(STS_FALED);
					RemoveTrans(pTrans);
				}
				else
				{
					// 如果传输数据出现错误重头再传输
					pTrans->MoveReadingOffset(0);
					pTrans->IncTryNum();

					const U32 nDataLen = custom_min(int(pTrans->GetLength()), int(PACKET_PAYLOAD_LEN_MAX));

					if (nDataLen > 0)
					{
						CDataPacket objRequestPacket;

						objRequestPacket.InitialT<TRANSFER_STREAM_DATA_REQUEST>(
							GetMsgId()
							, MT_TRANSFER_STREAM_DATA
							, OT_REQUEST
							, nDataLen);

						TRANSFER_STREAM_DATA_REQUEST* pTransferRequest =
							(TRANSFER_STREAM_DATA_REQUEST*)objRequestPacket.GetHeaderPtr();

						pTransferRequest->nId = NTOHQ(pTrans->GetID());
						pTransferRequest->nSize = HTONL(nDataLen);
						pTransferRequest->nOffset = NTOHQ(pTrans->GetReadingOffset());
						pTrans->Read(GetVarDataPtr<TRANSFER_STREAM_DATA_REQUEST>((unsigned char*)pTransferRequest)
							, nDataLen
							, false);
						pEndpoint->Send(&objRequestPacket);
					}
				}
			}
			}
		}
	}
}

//--------------------------------------------------------------------------------
/// <summary>
/// 处理移动流传输偏移位置消息请求
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="pDataPacket">指向当前数据包对象的指针</param>
/// <created>Andy,2019-03-29</created>
/// <changed>Andy,2019-03-29</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline void CTransactionServiceT<T, EndpointT>::OnMoveStreamOffsetRequest(
	EndpointT pEndpoint
	, CDataPacket* pDataPacket)
{
	U64 nStatusCode = 0;
	MOVE_STREAM_OFFSET_REQUEST* pRequest = (MOVE_STREAM_OFFSET_REQUEST*)pDataPacket->GetHeaderPtr();
	CStreamTransAbstractPtr pTrans = std::dynamic_pointer_cast<CStreamTransAbstract>(
		m_objTransManager.Lookup(NTOHQ(pRequest->nId)));

	if (nullptr != pTrans)
	{
		pTrans->MoveReadingOffset(NTOHQ(pRequest->nOffset));
	}
	else
	{
		nStatusCode = ES_NOT_FOUND_TRANS;
	}

	CDataPacket objResponsePacket;
	objResponsePacket.InitialT<MOVE_STREAM_OFFSET_REPONSE>(
		pDataPacket->GetPacketId()
		, (WORD)pDataPacket->GetPacketType()
		, BYTE(OT_RESPONSE | ((0 == nStatusCode) ? OR_SUCCESS : OR_FAILURE)));

	MOVE_STREAM_OFFSET_REPONSE* pResponsePacket = (MOVE_STREAM_OFFSET_REPONSE*)objResponsePacket.GetHeaderPtr();

	pResponsePacket->nId = NTOHQ(pTrans->GetID());
	pResponsePacket->nOffset = pRequest->nOffset;
	pResponsePacket->nStatusCode = (U32)NTOHQ(nStatusCode);

	pEndpoint->Send(&objResponsePacket);
}

//--------------------------------------------------------------------------------
/// <summary>
/// 处理移动流偏移应答
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="pDataPacket">指向当前数据包对象的指针</param>
/// <created>Andy,2019-03-30</created>
/// <changed>Andy,2019-03-30</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline void CTransactionServiceT<T, EndpointT>::OnMoveStreamOffsetResponse(
	EndpointT /*pEndpoint*/
	, CDataPacket* pDataPacket)
{
	MOVE_STREAM_OFFSET_REPONSE* pRequest = (MOVE_STREAM_OFFSET_REPONSE*)pDataPacket->GetHeaderPtr();
	CStreamTransAbstractPtr pTrans = std::dynamic_pointer_cast<CStreamTransAbstract>(
		m_objTransManager.Lookup(NTOHQ(pRequest->nId)));

	if (nullptr != pTrans)
	{
		if (pDataPacket->GetPacketFlag() & OR_SUCCESS)
		{
			pTrans->MoveWritingOffset(NTOHQ(pRequest->nOffset));
		}
	}
}


//--------------------------------------------------------------------------------
/// <summary>
/// 处理终止流传输请求
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="pDataPacket">指向当前数据包对象的指针</param>
/// <created>Andy,2020/3/27</created>
/// <changed>Andy,2020/3/27</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline  void CTransactionServiceT<T, EndpointT>::OnAbortTransferStreamRequest(
	EndpointT pEndpoint
	, CDataPacket* pDataPacket)
{
	if (nullptr != pDataPacket)
	{
		ABORT_TRANSFER_STREAM_REQUEST* pRequest = (ABORT_TRANSFER_STREAM_REQUEST*)pDataPacket->GetHeaderPtr();
		CStreamTransAbstractPtr pTrans = std::dynamic_pointer_cast<CStreamTransAbstract>(
			m_objTransManager.Lookup(NTOHQ(pRequest->nId)));

		RemoveTrans(pTrans);
		SendCommonResponse(pEndpoint, pDataPacket, OR_SUCCESS, NTOHQ(pRequest->nId));
	}
}


//--------------------------------------------------------------------------------
/// <summary>
/// 处理数据流同步请求
/// </summary>
/// <param name="pEndpoint">指向当前通信端点对象的指针</param>
/// <param name="pDataPacket">指向当前数据包对象的指针</param>
/// <created>Andy,2020/3/27</created>
/// <changed>Andy,2020/3/27</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline  void CTransactionServiceT<T, EndpointT>::OnSynStreamRequest(
	EndpointT pEndpoint
	, CDataPacket* pDataPacket)
{
	U32 nStatusCode = 0; ///< 返回响应结果状态码
	SYN_STREAM_REQUEST* pRequest = (SYN_STREAM_REQUEST*)pDataPacket->GetHeaderPtr();
	CTransAbstractPtr pTrans = m_objTransManager.Lookup(NTOHQ(pRequest->nId));
	CStreamTransAbstractPtr pStreamTrans = std::dynamic_pointer_cast<CStreamTransAbstract>(pTrans);

	if (nullptr != pStreamTrans)
	{
		pStreamTrans->SetType(NTOHS(pRequest->nType));
		pStreamTrans->SetLength(NTOHQ(pRequest->nSize));
		pStreamTrans->SetOrgLength(NTOHQ(pRequest->nSize));
		pStreamTrans->SetOrgMd5(((char*)pRequest->szMd5));

		pStreamTrans->MoveReadingOffset(0);
		pStreamTrans->MoveWritingOffset(0);
	}
	else
	{
		nStatusCode = ES_NOT_FOUND_TRANS;
	}

	CDataPacket objResponsePacket;

	objResponsePacket.InitialT<TRANSFER_STREAM_RESPONSE>(
		pDataPacket->GetPacketId()
		, (WORD)pDataPacket->GetPacketType()
		, BYTE(OT_RESPONSE | ((0 == nStatusCode) ? OR_SUCCESS : OR_FAILURE)));

	TRANSFER_STREAM_RESPONSE* pResponsePacket = (TRANSFER_STREAM_RESPONSE*)objResponsePacket.GetHeaderPtr();

	pResponsePacket->nId = pRequest->nId; ///< 本身是网络字节序号
	pResponsePacket->nStatusCode = NTOHQ(nStatusCode);

	pEndpoint->Send(&objResponsePacket);
}



//--------------------------------------------------------------------------------
/// <summary>
///  数据流传输完毕事件
/// </summary>
/// <param name="bSending">true:发送完毕,false:接收完毕</param>
/// <param name="pTrans">指向事务对象的指针</param>
/// <created>Andy,2020/3/28</created>
/// <changed>Andy,2020/3/28</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline  void CTransactionServiceT<T, EndpointT>::OnTransferStreamOver(
	bool /*bSending*/
	, CStreamTransAbstractPtr pTrans)
{
	// 数据已经正确的传输完毕，直接删除事务
	RemoveTrans(pTrans);
}

//--------------------------------------------------------------------------------
/// <summary>
/// 创建流
/// </summary>
/// <param name="nID">流id</param>
/// <param name="nType">流的类型</param>
/// <param name="lpMD5">流的md5值</param>
/// <param name="nSize">流的大小</param>
/// <returns>成功返回指向新建流对象的指针,否则返回null</returns>
/// <created>Leiyz,2019/5/23</created>
/// <changed>Andy,2020/1/2</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline  CTransAbstractPtr CTransactionServiceT<T, EndpointT>::CreateTrans(
	const U64 nID
	, const U32 nType
	, const U32 /*nExpires*/)
{
	CTransAbstractPtr pResult = m_objTransManager.CreateItem(N2S(CMemoryStreamTrans), nID);

	if (nullptr != pResult)
	{
		pResult->SetType(nType);
	}

	return pResult;
}


//--------------------------------------------------------------------------------
/// <summary>
/// 
/// </summary>
/// <param name="pTrans"></param>
/// <created>Andy,2020/3/28</created>
/// <changed>Andy,2020/3/28</changed>
//--------------------------------------------------------------------------------
template <class T, class EndpointT>
inline void CTransactionServiceT<T, EndpointT>::RemoveTrans(CTransAbstractPtr pTrans)
{
	if (nullptr != pTrans)
	{
		m_objTransManager.Remove(pTrans->GetID());
	}
}

