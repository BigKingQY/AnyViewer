/******************************************************************************
* 
* projectcost
* Version
* Copyright (C) 2007 AxSoft Co., Ltd.
* All Rights Reserved
* $Header: \cvsdata/vc/Common/SaxDES.h,v 1.3 2008/07/05 23:51:38 andy_developer Exp $
* 
*******************************************************************************
* 
* Description:CDES.h: interface for the CDES class.
//DES算法相应描述：

如何实现DES算法

原文：Matthew Fischer

DES( Data Encryption Standard)算法，于1977年得到美国政府的正式许可，是一种用56位密钥来加密64位数据的方法。DES算法以被应用于许多需要安全加密的场合。（如：UNIX的密码算法就是以DES算法为基础的）。下面是关于如何实现DES算法的语言性描述，如果您要其源代码，可以到Http//Assassin.yeah.net下载，后者您有任何问题也可以写信给我（Assassin@ynmail.com）。

1-1、变换密钥

取得64位的密钥，每个第8位作为奇偶校验位。

1-2、变换密钥。

1-2-1、舍弃64位密钥中的奇偶校验位，根据下表（PC-1）进行密钥变换得到56位的密钥，在变换中，奇偶校验位以被舍弃。

Permuted Choice 1 (PC-1)

57 49 41 33 25 17 9

1 58 50 42 34 26 18

10 2 59 51 43 35 27

19 11 3 60 52 44 36

63 55 47 39 31 23 15

7 62 54 46 38 30 22

14 6 61 53 45 37 29

21 13 5 28 20 12 4

1-2-2、将变换后的密钥分为两个部分，开始的28位称为C[0]，最后的28位称为D[0]。

1-2-3、生成16个子密钥，初始I=1。

1-2-3-1、同时将C[I]、D[I]左移1位或2位，根据I值决定左移的位数。见下表

I： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

左移位数： 1 1 2 2 2 2 2 2 1 2 2 2 2 2 2 1

1-2-3-2、将C[I]D[I]作为一个整体按下表（PC-2）变换，得到48位的K[I]

　

 Permuted Choice 2 (PC-2)

 14 17 11 24 1 5

 3 28 15 6 21 10

 23 19 12 4 26 8

 16 7 27 20 13 2

 41 52 31 37 47 55

 30 40 51 45 33 48

 44 49 39 56 34 53

 46 42 50 36 29 32

 1-2-3-3、从1-2-3-1处循环执行，直到K[16]被计算完成。


 2、处理64位的数据

 2-1、取得64位的数据，如果数据长度不足64位，应该将其扩展为64位（例如补零）

 2-2、将64位数据按下表变换（IP）

 Initial Permutation (IP)

 58 50 42 34 26 18 10 2

 60 52 44 36 28 20 12 4

 62 54 46 38 30 22 14 6

 64 56 48 40 32 24 16 8

 57 49 41 33 25 17 9 1

 59 51 43 35 27 19 11 3

 61 53 45 37 29 21 13 5

 63 55 47 39 31 23 15 7

 2-3、将变换后的数据分为两部分，开始的32位称为L[0]，最后的32位称为R[0]。

 2-4、用16个子密钥加密数据，初始I=1。

 2-4-1、将32位的R[I-1]按下表（E）扩展为48位的E[I-1]

 Expansion (E)

 32 1 2 3 4 5

 4 5 6 7 8 9

 8 9 10 11 12 13

 12 13 14 15 16 17

 16 17 18 19 20 21

 20 21 22 23 24 25

 24 25 26 27 28 29

 28 29 30 31 32 1

 2-4-2、异或E[I-1]和K[I]，即E[I-1] XOR K[I]

 2-4-3、将异或后的结果分为8个6位长的部分，第1位到第6位称为B[1]，第7位到第12位称为B[2]，依此类推，第43位到第48位称为B[8]。

 2-4-4、按S表变换所有的B[J]，初始J=1。所有在S表的值都被当作4位长度处理。

 2-4-4-1、将B[J]的第1位和第6位组合为一个2位长度的变量M，M作为在S[J]中的行号。

 2-4-4-2、将B[J]的第2位到第5位组合，作为一个4位长度的变量N，N作为在S[J]中的列号。

 2-4-4-3、用S[J][M][N]来取代B[J]。

 Substitution Box 1 (S[1])

 14 4 13 1 2 15 11 8 3 10 6 12 5 9 0 7

 0 15 7 4 14 2 13 1 10 6 12 11 9 5 3 8

 4 1 14 8 13 6 2 11 15 12 9 7 3 10 5 0

 15 12 8 2 4 9 1 7 5 11 3 14 10 0 6 13

 S[2]

 15 1 8 14 6 11 3 4 9 7 2 13 12 0 5 10

 3 13 4 7 15 2 8 14 12 0 1 10 6 9 11 5

 0 14 7 11 10 4 13 1 5 8 12 6 9 3 2 15

 13 8 10 1 3 15 4 2 11 6 7 12 0 5 14 9

 S[3]

 10 0 9 14 6 3 15 5 1 13 12 7 11 4 2 8

 13 7 0 9 3 4 6 10 2 8 5 14 12 11 15 1

 13 6 4 9 8 15 3 0 11 1 2 12 5 10 14 7

 1 10 13 0 6 9 8 7 4 15 14 3 11 5 2 12

 S[4]

 7 13 14 3 0 6 9 10 1 2 8 5 11 12 4 15

 13 8 11 5 6 15 0 3 4 7 2 12 1 10 14 9

 10 6 9 0 12 11 7 13 15 1 3 14 5 2 8 4

 3 15 0 6 10 1 13 8 9 4 5 11 12 7 2 14

 S[5]

 2 12 4 1 7 10 11 6 8 5 3 15 13 0 14 9

 14 11 2 12 4 7 13 1 5 0 15 10 3 9 8 6

 4 2 1 11 10 13 7 8 15 9 12 5 6 3 0 14

 11 8 12 7 1 14 2 13 6 15 0 9 10 4 5 3

 S[6]

 12 1 10 15 9 2 6 8 0 13 3 4 14 7 5 11

 10 15 4 2 7 12 9 5 6 1 13 14 0 11 3 8

 9 14 15 5 2 8 12 3 7 0 4 10 1 13 11 6

 4 3 2 12 9 5 15 10 11 14 1 7 6 0 8 13

 S[7]

 4 11 2 14 15 0 8 13 3 12 9 7 5 10 6 1

 13 0 11 7 4 9 1 10 14 3 5 12 2 15 8 6

 1 4 11 13 12 3 7 14 10 15 6 8 0 5 9 2

 6 11 13 8 1 4 10 7 9 5 0 15 14 2 3 12

 S[8]

 13 2 8 4 6 15 11 1 10 9 3 14 5 0 12 7

 1 15 13 8 10 3 7 4 12 5 6 11 0 14 9 2

 7 11 4 1 9 12 14 2 0 6 10 13 15 3 5 8

 2 1 14 7 4 10 8 13 15 12 9 0 3 5 6 11

 2-4-4-4、从2-4-4-1处循环执行，直到B[8]被替代完成。

 2-4-4-5、将B[1]到B[8]组合，按下表（P）变换，得到P。

 Permutation P

 16 7 20 21

 29 12 28 17

 1 15 23 26

 5 18 31 10

 2 8 24 14

 32 27 3 9

 19 13 30 6

 22 11 4 25

 2-4-6、异或P和L[I-1]结果放在R[I]，即R[I]=P XOR L[I-1]。

 2-4-7、L[I]=R[I-1]

 2-4-8、从2-4-1处开始循环执行，直到K[16]被变换完成。

 2-4-5、组合变换后的R[16]L[16]（注意：R作为开始的32位），按下表（IP-1）变换得到最后的结果。

 Final Permutation (IP**-1)

 40 8 48 16 56 24 64 32

 39 7 47 15 55 23 63 31

 38 6 46 14 54 22 62 30

 37 5 45 13 53 21 61 29

 36 4 44 12 52 20 60 28

 35 3 43 11 51 19 59 27

 34 2 42 10 50 18 58 26

 33 1 41 9 49 17 57 25

 
******************************************************************************/
#pragma once

enum DES_OPERATOR_TYPE
{
	DPT_ENCRYPT = 0,//加密
	DPT_DECRYPT     //解密
};

class CDES  
{
public:
	CDES();
	virtual ~CDES();	

	//DES算法的模式
	enum DES_MODE
	{
		DM_ECB		=	0,	//DM_ECB模式
		DM_CBC				//DM_CBC模式
	};

	typedef BOOL    (*PSubKey)[16][48];

	/*******************************************************************/
	/*
	函 数 名 称:	RunDes
	功 能 描 述：	执行DES算法对文本加解密
	参 数 说 明：	bType	:类型：加密DPT_ENCRYPT，解密DPT_DECRYPT
	bMode	:模式：DM_ECB,DM_CBC
	pInBuffer		:待加密串指针
	pOutBuffer		:待输出串指针
	nDataLen	:待加密串的长度，同时pOutBuffer的缓冲区大小应大于或者等于nDataLen
	pKey		:密钥(可为8位,16位,24位)支持3密钥
	nKeyLen	:密钥长度，多出24位部分将被自动裁减

	返回值 说明：	BOOL	:是否加密成功
	作       者:	邹德强
	更 新 日 期：	2003.12.19
	/*******************************************************************/
	static BOOL RunDes(DES_OPERATOR_TYPE bType,DES_MODE bMode,char* pInBuffer,char* pOutBuffer,unsigned nDataLen,const char* pKey,const BYTE nKeyLen);
protected:
	//计算并填充子密钥到SubKey数据中
	static void SetSubKey(PSubKey pSubKey, const char pKey[8]);

	//DES单元运算
	static void DES(char pOutBuffer[8], char pInBuffer[8], const PSubKey pSubKey, DES_OPERATOR_TYPE Type);
};


/*******************************************************************/
/*
函 数 名 称:	Transform
功 能 描 述：	把两个Bit流按表进行位转化
参 数 说 明：	pOutBuffer:	输出的Bit流[out]
pInBuffer:		输入的Bit流[in]
pTable:	转化需要的表指针
nLen:	转化表的长度

返回值 说明：	void
作       者:	邹德强
更 新 日 期：	2003.12.19
/*******************************************************************/
inline void Transform(BOOL *pOutBuffer, BOOL *pInBuffer, const char *pTable, int nLen)
{
	BOOL Tmp[256];

	for(int i=0; i<nLen; ++i)
	{
		Tmp[i] = pInBuffer[ pTable[i]-1 ];
	}
	memcpy(pOutBuffer, Tmp, nLen);
}


/*******************************************************************/
/*
函 数 名 称:	Xor
功 能 描 述：	把两个Bit流进行异或
参 数 说 明：	InA:	输入的Bit流[in][out]
InB:	输入的Bit流[in]
nLoop:	Bit流的长度

返回值 说明：	void
作       者:	邹德强
更 新 日 期：	2003.12.19
/*******************************************************************/
inline void Xor(BOOL *InA, const BOOL *InB, int nLen)
{
	nLen--;
	while(nLen >= 7)
	{	
		InA[nLen] ^= InB[nLen];
		InA[nLen - 1] ^= InB[nLen - 1];
		InA[nLen - 2] ^= InB[nLen - 2];
		InA[nLen - 3] ^= InB[nLen - 3];
		InA[nLen - 4] ^= InB[nLen - 4];
		InA[nLen - 5] ^= InB[nLen - 5];
		InA[nLen - 6] ^= InB[nLen - 6];
		InA[nLen - 7] ^= InB[nLen - 7];	

		nLen -= 8;
	}
	switch(nLen)
	{
	case 6:
		InA[6] ^= InB[6];
	case 5:
		InA[5] ^= InB[5];
	case 4:
		InA[4] ^= InB[4];
	case 3:
		InA[3] ^= InB[3];
	case 2:
		InA[2] ^= InB[2];
	case 1:
		InA[1] ^= InB[1];
	case 0:
		InA[0] ^= InB[0];
	}
}



