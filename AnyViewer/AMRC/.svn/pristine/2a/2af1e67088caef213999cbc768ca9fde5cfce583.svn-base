#include "stdafx.h"
#include "ProfileLogger.h"
#include "SDPSingleton.H"
#include "GetCPUTime.h"

#include <algorithm>
#include <numeric> 
#include <utility> 

// does not works on XP
// #include "Realtimeapiset.h"

CProfileLogger::~CProfileLogger()
{
}

CProcessorTimes CProfileLogger::checkPoint(const TCHAR *description)
{
	std::lock_guard<std::recursive_mutex> objAutoLocker(m_objMapMutex);

	/*
	try {
	  QueryProcessCycleTime(GetCurrentProcess(), &m_objLastProcTime.cycle);
	}
	catch (...) {
	  m_lastCycle = 0;
	}*/
	CProcessorTimes objProcTimes;

	objProcTimes.cycle = m_objLastProcTime.cycle;
	m_objLastProcTime.cycle = rdtsc();
	objProcTimes.cycle = m_objLastProcTime.cycle - objProcTimes.cycle;

	objProcTimes.process = m_objLastProcTime.process;
	m_objLastProcTime.process = getCPUTime();
	objProcTimes.process = m_objLastProcTime.process - objProcTimes.process;

	objProcTimes.kernel = m_objLastProcTime.kernel;
	m_objLastProcTime.kernel = getKernelTime();
	objProcTimes.kernel = m_objLastProcTime.kernel - objProcTimes.kernel;

	objProcTimes.wall = m_objLastProcTime.wall;
	m_objLastProcTime.wall = CDateTime::now();
	objProcTimes.wall = m_objLastProcTime.wall - objProcTimes.wall;

	// #if DROP_TIME_STAT  // test code
	m_mapCheckPoints[description].push_back(m_objLastProcTime);
	// #endif
	return objProcTimes;
}

typedef std::pair<CProcessorTimes, const TCHAR *> CHECKPPOINTPAIR;
typedef std::pair<const TCHAR *, const TCHAR *> STRINGPAIR;

// helper function for std::sort

bool pairCompare(const CHECKPPOINTPAIR& objFirstElem, const CHECKPPOINTPAIR& objSecondElem) 
{
	return objFirstElem.first.cycle < objSecondElem.first.cycle;
}

std::vector<TCHAR> printVectorStats(const TCHAR *lpHeader, const TCHAR *lpTag1, const TCHAR *lpTag2, std::vector<double> v)
{
	double nMin = *std::min_element(v.begin(), v.end());
	double nMax = *std::max_element(v.begin(), v.end());
	int nNum = v.size();
	double nAvg = std::accumulate(v.begin(), v.end(), 0.) / nNum;
	const TCHAR *lpFMT = L"%s for %s - %s distance: nAvg: %f, nMin: %f, nMax: %f, executed %d times\n";
	int nCount = _sctprintf(lpFMT, lpHeader, lpTag1, lpTag2, nAvg, nMin, nMax, nNum);

	nCount++;
	
	std::vector<TCHAR> arrFormattedString(nCount);

	_stprintf_s(&arrFormattedString.front(), nCount, lpFMT, lpHeader, lpTag1, lpTag2, nAvg, nMin, nMax, nNum);

	return arrFormattedString;
}

std::vector<std::vector<TCHAR>> CProfileLogger::dropStat()
{
	std::lock_guard<std::recursive_mutex> objAutoLocker(m_objMapMutex);
	std::vector<std::vector<TCHAR>> arrResultStrings;

	if (m_mapCheckPoints.size() == 0)
		return arrResultStrings;

	CDateTime dtDuring = CDateTime::now() - m_objLastDrop;

	if (dtDuring.getTime() / 1000. < m_nDropRate)
	{
		return arrResultStrings;
	}

	m_objLastDrop = CDateTime::now();

	std::vector<CHECKPPOINTPAIR> arrCheckPointPairs;

	// Build vector with times-description pairs and sort it by times order

	for (auto i = m_mapCheckPoints.begin(); i != m_mapCheckPoints.end(); i++)
	{
		std::vector<CProcessorTimes> arrTimes = (*i).second;

		for (auto t = arrTimes.begin(); t != arrTimes.end(); t++)
		{
			arrCheckPointPairs.push_back(CHECKPPOINTPAIR((*t), (*i).first));
		}
	}

	std::sort(arrCheckPointPairs.begin(), arrCheckPointPairs.end(), pairCompare);

	if (arrCheckPointPairs.size() == 0)
		return arrResultStrings;

	// calc deltas for consequent points
	struct ProcessorTimesDeltas 
	{
		std::vector<double> deltac; // CPU cycles deltas
		std::vector<double> deltap; // CProcessInfo time deltas
		std::vector<double> deltak; // Kernel time deltas
	};

	std::map<STRINGPAIR, ProcessorTimesDeltas> deltas;
	std::vector<CHECKPPOINTPAIR>::iterator p = arrCheckPointPairs.begin();

	for (;;)
	{
		const TCHAR *lpTag1 = (*p).second;
		CProcessorTimes pt1 = (*p).first;

		++p;

		if (p == arrCheckPointPairs.end())
			break;

		CProcessorTimes pt2 = (*p).first;
		const TCHAR *lpTag2 = (*p).second;
		STRINGPAIR sp = STRINGPAIR(lpTag1, lpTag2);

		deltas[sp].deltac.push_back(double(pt2.cycle - pt1.cycle) / 1000000.);
		deltas[sp].deltap.push_back(pt2.process - pt1.process);
		deltas[sp].deltak.push_back(pt2.kernel - pt1.kernel);
	}

	// print results
	for (auto d = deltas.begin(); d != deltas.end(); ++d) 
	{
		const TCHAR *lpTag1 = (*d).first.first;
		const TCHAR *lpTag2 = (*d).first.second;
		std::vector<TCHAR> str = printVectorStats(L"CPU cycles", lpTag1, lpTag2, (*d).second.deltac);

		arrResultStrings.push_back(str);
		str = printVectorStats(L"CProcessInfo times", lpTag1, lpTag2, (*d).second.deltap);
		arrResultStrings.push_back(str);
		str = printVectorStats(L"Kernel times", lpTag1, lpTag2, (*d).second.deltak);
		arrResultStrings.push_back(str);
	}

	m_mapCheckPoints.clear();

	return arrResultStrings;
}


CProfileLogger* GetProfileLogger()
{
	return CGlobleSingleton<CProfileLogger>::Instance();
}