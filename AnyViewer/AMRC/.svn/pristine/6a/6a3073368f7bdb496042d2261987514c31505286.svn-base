/////////////////////////////////////////////////////////////////////
/// @file Sunday.cpp
/// @brief Sunday字符串查找算法类实现
/// 
/// @author andy
/// @version 1.0
/// @date 2020.4.1
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Sunday.h"


CSundaySearch::CSundaySearch()
{
}

CSundaySearch::~CSundaySearch()
{
}



//--------------------------------------------------------------------------------
/// <summary>
/// 初始化算法移动表
/// </summary>
/// <param name="strPattern"></param>
/// <param name="bCase"></param>
/// <created>Andy,2020/4/2</created>
/// <changed>Andy,2020/4/2</changed>
//--------------------------------------------------------------------------------
void CSundaySearch::InitShiftTable(const std::string strPattern, const bool bCase)
{
	m_strPattern = strPattern;
	m_bCase = bCase;

	const size_t PATTERN_LEN = strPattern.size();

	for (size_t i = 0; i < SHIFT_TABLE_SIZE; i++)
	{
		m_arrShiftTable[i] = (WORD)(PATTERN_LEN + 1);
	}

	if (bCase)
	{
		for (size_t i = 0; i < PATTERN_LEN; i++)
		{
			m_arrShiftTable[(BYTE)(strPattern[i])] = (WORD)(PATTERN_LEN - i);
		}
	}
	else
	{
		for (size_t i = 0; i < PATTERN_LEN; i++)
		{
			m_arrShiftTable[(BYTE)tolower(strPattern[i])] = (WORD)(PATTERN_LEN - i);
			m_arrShiftTable[(BYTE)toupper(strPattern[i])] = (WORD)(PATTERN_LEN - i);
		}
	}
}


/*-----------------------------------------------------------------
|  函数名称  : CSaxReportControl::Search
|  描    述  :
|  参    数  : CString&  strItemText――
|  返 回 值  : TRUE----
|              false---
|  修改记录  : 2007-11-16 19:16:03   -huangdy-   创建
-----------------------------------------------------------------*/
int CSundaySearch::Search(const char* pSrc,const size_t Length)
{	
	if (nullptr == pSrc || Length <= 0)
	{
		return -1;
	}

	const size_t PATTERN_LEN = m_strPattern.size();	

	if (m_bCase)
	{
		/* Handle 1 Byte patterns - it's a faster loop */
		if (1 == PATTERN_LEN)
		{
			for (size_t i = 0; i < Length; i++)
			{
				if (pSrc[i] == m_strPattern[0])
				{
					return i;
				}
			}
		}
		else
		{
			// start searching...
			size_t t = 0, tx = 0;

			while (tx + PATTERN_LEN <= Length) // the main searching loop
			{
				t = tx;

				size_t i = 0;

				for (; i < PATTERN_LEN; i++, ++t)
				{
					if ((size_t)m_strPattern[i] != (size_t)pSrc[t]) // found a mismatch
					{
						break;
					}
				}

				if (i == PATTERN_LEN) // Yes! we found it!
				{					
					return tx;
				}

				tx += m_arrShiftTable[(BYTE)pSrc[tx + PATTERN_LEN]]; // move the pattern by a distance
			}
		}
	}
	else
	{
		/* Handle 1 Byte patterns - it's a faster loop */
		if (1 == PATTERN_LEN)
		{
			for (size_t i = 0; i < Length; i++)
			{
				if ((int)pSrc[i] == (int)m_strPattern[0]
					|| tolower(pSrc[i]) == m_strPattern[0]
					|| toupper(pSrc[i]) == m_strPattern[0])
				{
					return i;
				}
			}
		}
		else
		{
			// start searching...
			size_t t = 0, tx = 0;

			while (tx + PATTERN_LEN <= Length) // the main searching loop
			{
				t = tx;

				size_t i = 0;
				for (; i < PATTERN_LEN; i++, ++t)
				{
					if (m_strPattern[i] != tolower(pSrc[t])
						&& m_strPattern[i] != toupper(pSrc[t])) // found a mismatch
					{
						break;
					}
				}

				if (i == PATTERN_LEN) // Yes! we found it!
				{
					return tx;
				}

				tx += m_arrShiftTable[(BYTE)pSrc[tx + PATTERN_LEN]]; // move the pattern by a distance
			}
		}
	}

	return -1;
}