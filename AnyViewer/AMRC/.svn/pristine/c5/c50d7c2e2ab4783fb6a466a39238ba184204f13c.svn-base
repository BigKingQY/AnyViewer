///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  
/// @brief 数据流事务抽象类、内存数据流事务和文件数据流事务实现
/// 
///
/// @author 黄丽云
/// @version 1.0
/// @date    2019-3-22
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "StreamTransAbstract.h"
#include <cassert>
#include <algorithm>
#include <openssl/md5.h>
#include "SDPFactory.h"

#ifndef WIN32
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h> 
#include <sys/file.h>
#endif


REGISTER_CLASS(CMemoryStreamTrans)
REGISTER_CLASS(CFileStreamTrans)

//--------------------------------------------------------------------------------
/// <summary>
/// ! Read the current character from stream without moving the read cursor.
/// </summary>
/// <returns></returns>
/// <created>Andy,2019-03-26</created>
/// <changed>Andy,2019-03-26</changed>
//--------------------------------------------------------------------------------
CStreamTransAbstract::Ch CStreamTransAbstract::Peek()
{
	Ch chResult = 0;

	Read((BYTE*)&chResult, 1, false);

	return chResult;
}

//--------------------------------------------------------------------------------
/// <summary>
/// ! Read the current character from stream and moving the read cursor to next character.
/// </summary>
/// <returns></returns>
/// <created>Andy,2019-03-26</created>
/// <changed>Andy,2019-03-26</changed>
//--------------------------------------------------------------------------------
CStreamTransAbstract::Ch CStreamTransAbstract::Take()
{
	Ch chResult = 0;

	Read((BYTE*)&chResult, 1, true);

	return chResult;
}

// ********************************************************************************
/// <summary>
/// 获取状态描述
/// </summary>
/// <returns></returns>
/// <created>Leiyz,2019/6/20</created>
/// <changed>Leiyz,2019/6/20</changed>
// ********************************************************************************
std::string CStreamTransAbstract::GetStatusDesc()
{
    std::string strResult;
    switch (m_nStatus)
    {
    case STS_INIT:
        strResult = "初始状态";
        break;
    case STS_TRANS:
        strResult = "正在传输...";
        break;
    case STS_FALED:
        strResult = "传输失败";
        break;
    case STS_CANCEL:
        strResult = "传输已取消";
        break;
    case STS_SUCCESS:
        strResult = "成功";
        break;
    default:
        break;
    }

    return strResult;
}



CStreamTransAbstract::CStreamTransAbstract(const U32 nType)
    : CTransAbstract(nType)
	, m_nTryNum(0)
    , m_nSrcAccount(0)
	, m_nDstAccount(0)
    , m_nStatus(STS_INIT)
	, m_bQuickMode(false)
{
}

CStreamTransAbstract::~CStreamTransAbstract()
{
}


// ********************************************************************************
// CTransFactory 内存流事务
// ********************************************************************************
CMemoryStreamTrans::CMemoryStreamTrans()
    :CStreamTransAbstract(TST_MEMORY)
{
}

CMemoryStreamTrans::~CMemoryStreamTrans()
{
}

//--------------------------------------------------------------------------------
/// <summary>
/// 从数据流中读取数据
/// </summary>
/// <param name="pBuffer">接受数据的缓冲区</param>
/// <param name="nLength">需要读取数据的长度</param>
/// <param name="bMoveCursor">true:需要移动读指针，否则不需要</param>
/// <returns></returns>
/// <created>Leiyz,2019-03-14</created>
/// <changed>Andy,2019-03-26</changed>
//--------------------------------------------------------------------------------
int CMemoryStreamTrans::Read(BYTE * pBuffer, U32 nLength, bool bMoveCursor)
{
    assert(nullptr != pBuffer);
    int nResult = 0;

    if (nullptr != pBuffer)
    {
		nResult = m_objData.Read(pBuffer, nLength, bMoveCursor);
    }

    return nResult;
}

// ********************************************************************************
/// <summary>
/// 
/// </summary>
/// <param name="pBuffer"></param>
/// <param name="nLength"></param>
/// <returns></returns>
/// <created>Leiyz,2019/3/14</created>
/// <changed>Leiyz,2019/3/14</changed>
// ********************************************************************************
bool CMemoryStreamTrans::Write(const BYTE* pBuffer, U32 nLength)
{
    assert(nullptr != pBuffer);
    bool bResult = false;

    if (nullptr != pBuffer)
    {
        m_objData.Write(pBuffer, nLength);
        bResult = true;
    }
    
    return bResult;
}

// ********************************************************************************
/// <summary>
/// 
/// </summary>
/// <param name="nOffset"></param>
/// <created>Leiyz,2019/3/14</created>
/// <changed>Leiyz,2019/3/14</changed>
// ********************************************************************************
bool CMemoryStreamTrans::MoveReadingOffset(U64 nOffset)
{
    bool bResult = false;

    if (nOffset <= U64(m_objData.GetCurWritingPos()))
    {
        m_objData.SetCurReadingPos((int)nOffset);
        bResult = true;
    }

    return bResult;
}

//--------------------------------------------------------------------------------
/// <summary>
/// 移动写指针
/// </summary>
/// <param name="nOffset">相对于开头的偏移</param>
/// <returns></returns>
/// <created>Andy,2019-03-25</created>
/// <changed>Andy,2019-03-25</changed>
//--------------------------------------------------------------------------------
bool CMemoryStreamTrans::MoveWritingOffset(U64 nOffset)
{
	bool bResult = false;

	if (nOffset < m_objData.GetSize())
	{
		m_objData.SetCurWritingPos((int)nOffset);
		bResult = true;
	}

	return bResult;
}

std::string CMemoryStreamTrans::CalcMd5()
{
    std::string strMd5;

    if (0 == m_objData.GetDataLen())
    {
        return strMd5;
    }

    MD5_CTX ctx;
    
    MD5_Init(&ctx);
    MD5_Update(&ctx, m_objData.GetDataHeadPtr(), m_objData.GetDataLen());
   
    unsigned char szDigest[16] = { 0 };

    MD5_Final(szDigest, &ctx);
    ConvertBinToHexText(szDigest, 16, strMd5);

    return strMd5;
}

void CMemoryStreamTrans::SetLength(U64 nLength)
{
	m_objData.Allocate((U32)nLength);
}

bool CMemoryStreamTrans::TransferOver()
{	
	return (U64(m_objData.GetDataLen()) == GetOrgLength());
}

void CMemoryStreamTrans::SetOrgLength(U64 nOrgLength)
{
	CStreamTransAbstract::SetOrgLength(nOrgLength);
	m_objData.Allocate((int)nOrgLength);

}

void CMemoryStreamTrans::AnsiToUtf8()
{
    std::string strAnsi((char*)GetBuffer(), (U32)GetLength());
    std::string strUtf8 = CLYCodeCvt::ANSIToUTF8(strAnsi);
   
    m_objData.Empty();
    Write((const BYTE*)strUtf8.data(), strUtf8.size());
}

void CMemoryStreamTrans::Utf8ToAnsi()
{
    std::string strUtf8((char*)GetBuffer(), (U32)GetLength());
    std::string strAnsi = CLYCodeCvt::UTF8ToANSI(strUtf8);
    m_objData.Empty();
    Write((const BYTE*)strAnsi.data(), strAnsi.size());
}

// ********************************************************************************
// CFileStreamTrans 文件流事务
// ********************************************************************************
CFileStreamTrans::CFileStreamTrans()
    :CStreamTransAbstract(TST_FILE)
    , m_nOffset(0)
{
    ;
}

CFileStreamTrans::~CFileStreamTrans()
{
    if (m_objStream.is_open())
    {
        m_objStream.close();
    }

#ifndef WIN32
	Unlock();
#endif

	
}

// ********************************************************************************
/// <summary>
/// 
/// </summary>
/// <param name="pBuffer"></param>
/// <param name="nLength"></param>
/// <returns></returns>
/// <created>Leiyz,2019/3/14</created>
/// <changed>Leiyz,2019/3/14</changed>
// ********************************************************************************
int CFileStreamTrans::Read(BYTE * pBuffer, U32 nLength, bool bMoveCursor)
{
    assert(m_objStream.is_open() && nullptr != pBuffer);

    if (!m_objStream.is_open() || nullptr == pBuffer)
    {
        return 0;
    }

    U64 nPos = m_objStream.tellg();
    U64 nSize = newfs::file_size(m_objPath) - nPos;

    nSize = std::min<U64>(nSize, nLength);
    memset(pBuffer, 0, nLength);
    m_objStream.read((char*)pBuffer, nSize);

	if (bMoveCursor)
	{
		MoveReadingOffset(nPos);
	}

    return int(nSize);
}

// ********************************************************************************
/// <summary>
/// 
/// </summary>
/// <param name="pBuffer"></param>
/// <param name="nLength"></param>
/// <returns></returns>
/// <created>Leiyz,2019/3/14</created>
/// <changed>Leiyz,2019/3/14</changed>
// ********************************************************************************
bool CFileStreamTrans::Write(const BYTE *pBuffer, U32 nLength)
{
    assert(m_objStream.is_open() && nullptr != pBuffer);

    if (!m_objStream.is_open() || nullptr == pBuffer)
    {
        return false;
    }

    m_objStream.write((const char*)pBuffer, nLength);

    return true;
}

bool CFileStreamTrans::MoveReadingOffset(U64 nOffset)
{
    U64 nSize = newfs::file_size(m_objPath);
    
	if (nOffset > nSize)
    {
        return false;
    }

    m_objStream.seekg(nOffset, std::ios::beg);

    return m_objStream.good();
}

bool CFileStreamTrans::MoveWritingOffset(U64 nOffset)
{
	U64 nSize = newfs::file_size(m_objPath);

	if (nOffset > nSize)
	{
		return false;
	}

	m_objStream.seekp(nOffset, std::ios::beg);

	return true;
}

// ********************************************************************************
/// <summary>
/// 计算md5
/// </summary>
/// <returns></returns>
/// <created>Leiyz,2019/3/15</created>
/// <changed>Leiyz,2019/3/15</changed>
// ********************************************************************************
std::string CFileStreamTrans::CalcMd5()
{
    std::string strMd5;

    if (m_objStream.is_open())
    {
        std::streampos nPos = m_objStream.tellg();
        
        MoveReadingOffset(0);

        const int BUF_LENGTH = 4096;
        char buffer[BUF_LENGTH] = { 0 };
        unsigned char digest[16] = { 0 };
        MD5_CTX ctx;

        MD5_Init(&ctx);

        while (m_objStream.good() && !m_objStream.eof())
        {
            m_objStream.read(buffer, BUF_LENGTH);
            int nRead = int(m_objStream.gcount());
            MD5_Update(&ctx, buffer, nRead);
        }       
        MD5_Final(digest, &ctx);
        
        m_objStream.clear();
        m_objStream.seekg(nPos);
        assert(m_objStream.good());
        ConvertBinToHexText(digest, 16, strMd5);
    }

    return strMd5;
}

void CFileStreamTrans::SetLength(U64 /*nLength*/)
{
	assert(false); //Invalid operator!

}

U64 CFileStreamTrans::GetLength()
{
	return (newfs::file_size(m_objPath) - GetReadingOffset());
}

U64 CFileStreamTrans::GetReadingOffset()
{
    assert(m_objStream.good());
	return m_objStream.tellg();
}

bool CFileStreamTrans::TransferOver()
{
    U64 nPos = m_objStream.tellp();
	return (nPos == GetOrgLength());
}

U32 CFileStreamTrans::GetTransferPercent()
{
    return U32(GetReadingOffset() * 100 / newfs::file_size(m_objPath));
}


// ********************************************************************************
/// <summary>
/// 打开文件
/// </summary>
/// <param name="strFile"></param>
/// <param name="bRead">读的方式打开</param>
/// <returns></returns>
/// <created>Leiyz,2019/3/14</created>
/// <changed>Leiyz,2019/3/14</changed>
// ********************************************************************************
bool CFileStreamTrans::Open(const std::string& strFile, bool bRead, std::ios_base::openmode nMode)
{
    bool bResult = false;

    if (m_objStream.is_open())
    {
        m_objStream.close();
    }

	if (!bRead)
	{
		std::remove(strFile.c_str());
	}

    m_objPath = strFile;

    if (!newfs::exists(m_objPath))
    {
        if (bRead)
        {
            return bResult;
        }

        if (!newfs::exists(m_objPath.parent_path()))
        {
            newfs::create_directories(m_objPath.parent_path());
        }
        nMode |= std::ios_base::trunc;
    }

    m_objStream.open(m_objPath, nMode);
    bResult = m_objStream.is_open();

    if (bResult)
    {
		if (bRead)
		{
			bResult = MoveReadingOffset(0);
		}
		else
		{

		}
    }

    return bResult;
}

#ifndef WIN32
//--------------------------------------------------------------------------------
/// <summary>
/// 锁住当前的文件
/// </summary>
/// <returns></returns>
/// <created>Andy,2020/1/7</created>
/// <changed>Andy,2020/1/7</changed>
//--------------------------------------------------------------------------------
bool CFileStreamTrans::Lock()
{
	bool bResult = false;
	m_nfd = open(m_objPath.parent_path().c_str(), O_RDONLY);

	if (-1 != m_nfd)
	{
		bResult = (-1 != flock(m_nfd, LOCK_EX | LOCK_NB));

		if (!bResult)
		{
			close(m_nfd);
			m_nfd = -1;
		}
	}

	return bResult;
}

//--------------------------------------------------------------------------------
/// <summary>
/// 解锁当前的文件
/// </summary>
/// <returns></returns>
/// <created>Andy,2020/1/8</created>
/// <changed>Andy,2020/1/8</changed>
//--------------------------------------------------------------------------------
bool CFileStreamTrans::Unlock()
{
	bool bResult = false;

	if (-1 != m_nfd)
	{
		flock(m_nfd, LOCK_UN);
		close(m_nfd);
		m_nfd = -1;
		bResult = true;
	}

	return bResult;
}
#endif
