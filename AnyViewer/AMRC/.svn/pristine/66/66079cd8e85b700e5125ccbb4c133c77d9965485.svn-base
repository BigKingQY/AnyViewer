///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  SLCTLogParser.cpp
/// @brief SLCT算法类实现
/// 
/// SLCT用于提取日志记录中的模式，并发现未知的模式(可能是异常)
///
/// @author 黄丽云
/// @version 1.0
/// @date        2020-6-9
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#include "SLCTLogParser.h"
#include "CServerApp.h"
#include <string.h>

const unsigned int MODE_COUNT_MAX = 10240;


CSLCTLogParser::CSLCTLogParser()
{
}


CSLCTLogParser::~CSLCTLogParser()
{
}

//--------------------------------------------------------------------------------
/// <summary>
/// 初始化分隔符号表
/// 用分割字符的值作为索引,把对应字符表中值设置为true,其它设置为false
/// </summary>
/// <returns></returns>
/// <created>Andy,2020/6/10</created>
/// <changed>Andy,2020/6/10</changed>
//--------------------------------------------------------------------------------
bool CSLCTLogParser::Init()
{
	memset(m_arrSeparator, false, sizeof(m_arrSeparator));

	m_arrSeparator[' '] = true;
	m_arrSeparator[';'] = true;
	m_arrSeparator['='] = true;
	m_arrSeparator[':'] = true;
	m_arrSeparator['('] = true;
	m_arrSeparator[')'] = true;
	m_arrSeparator['['] = true;
	m_arrSeparator[']'] = true;
	m_arrSeparator['{'] = true;
	m_arrSeparator['}'] = true;
	m_arrSeparator['"'] = true;

	return true;
}

//--------------------------------------------------------------------------------
/// <summary>
/// 添加单词信息
/// </summary>
/// <param name="refWord">单词</param>
/// <param name="nFreq">频率</param>
/// <created>Andy,2020/6/9</created>
/// <changed>Andy,2020/6/9</changed>
//--------------------------------------------------------------------------------
void CSLCTLogParser::AppendWordsFreq(const std::string & refWord, const int nFreq)
{
	m_mapWordsFreq[refWord] = nFreq;
}


//--------------------------------------------------------------------------------
/// <summary>
/// 分割单词,并存储到数组中
/// </summary>
/// <param name="refLogLine"></param>
/// <param name="pWordsList"></param>
/// <created>Andy,2020/6/10</created>
/// <changed>Andy,2020/6/10</changed>
//--------------------------------------------------------------------------------
void CSLCTLogParser::SplitWord(
	const std::string & refLogLine
	, CWordsListPtr pWordsList) const
{
	enum ANALYSIS_STATUS
	{
		AS_BEGIN = 0,   ///< 单词开始位置
		AS_END = 1,     ///< 单词结束位置
	};

	//#ifdef DEBUG
	//	std::string strTmp = "TCP重复应答";
	//	bool bFlag = IsGBK((const unsigned char*)strTmp.c_str(), strTmp.size());
	//	bFlag = IsUtf8((const unsigned char*)strTmp.c_str(), strTmp.size());
	//	LOG_INFO("%s", strTmp.c_str());
	//#endif

	ANALYSIS_STATUS nStatus = AS_BEGIN;
	std::string strWord;
	const size_t LOG_LINE_LEN = refLogLine.size();

	for (size_t i = 0; i < LOG_LINE_LEN; i++)
	{
		const char chCur = refLogLine[i];

		if (m_arrSeparator[(unsigned char)chCur] || i + 1 == LOG_LINE_LEN)
		{
			if (strWord.size() > 0)
			{
#ifdef DEBUG
				//bool bFlag = IsUtf8((const unsigned char*)strWord.c_str(), strWord.size());
				//LOG_INFO("%s", strWord.c_str());
#endif

				CWordsStatPtr pWordEntry = std::make_shared<CWordsStat>(strWord);

				pWordsList->push_back(pWordEntry);
				strWord.clear();
			}
		}
		else
		{
			strWord += chCur;
		}
	}

}

//--------------------------------------------------------------------------------
/// <summary>
/// 查找单词对应的统计信息
/// </summary>
/// <param name="refWord"></param>
/// <param name="pWordsList"></param>
/// <returns></returns>
/// <created>Andy,2020/6/10</created>
/// <changed>Andy,2020/6/10</changed>
//--------------------------------------------------------------------------------
CWordsStatPtr CSLCTLogParser::LookupWordStat(
	const std::string & refWord
	, const CWordsListPtr pWordsList) const
{
	CWordsStatPtr pResult = nullptr;

	for (CWordsStatPtr pWordsStat : *pWordsList)
	{
		if (pWordsStat->GetWord() == refWord)
		{
			pResult = pWordsStat;
		}
	}

	return pResult;
}

//--------------------------------------------------------------------------------
/// <summary>
/// 创建模式
/// </summary>
/// <param name="refLogLine">被处理日志行</param>
/// <param name="pWordsList">单词信息表</param>
/// <param name="refModel">新创建的模式</param>
/// <created>Andy,2020/6/10</created>
/// <changed>Andy,2020/6/10</changed>
//--------------------------------------------------------------------------------
void CSLCTLogParser::CreateMode(
	const std::string& refLogLine
	, const CWordsListPtr pWordsList
	, std::string& refModel) const
{
	bool nPreWordExcluded = false;
	std::string strWord;
	const size_t LOG_LINE_LEN = refLogLine.size();

	for (size_t i = 0; i < LOG_LINE_LEN; i++)
	{
		const char chCur = refLogLine[i];

		if (m_arrSeparator[(unsigned char)chCur] || i + 1 == LOG_LINE_LEN)
		{
			if (strWord.size() > 0)
			{
				CWordsStatPtr pWordsStat = LookupWordStat(strWord, pWordsList);

				assert(nullptr != pWordsStat);

				if (pWordsStat->GetExclude())
				{
					if (!nPreWordExcluded || chCur != ' ')
					{
						refModel += "*";
					}

					nPreWordExcluded = true;
				}
				else
				{
					refModel += strWord;
					nPreWordExcluded = false;
				}

				strWord.clear();
			}

			refModel += chCur;
		}
		else
		{
			strWord += chCur;
		}
	}
}

//--------------------------------------------------------------------------------
/// <summary>
/// 判断第一个模式是否包含第二个模式
/// </summary>
/// <param name="pWordsList1"></param>
/// <param name="pWordsList2"></param>
/// <returns></returns>
/// <created>Andy,2020/6/11</created>
/// <changed>Andy,2020/6/11</changed>
//--------------------------------------------------------------------------------
bool CSLCTLogParser::CheckContainModel(CWordsListPtr pWordsList1, CWordsListPtr pWordsList2)
{
	bool bMatch = false;

	const size_t SRC_WORDS_COUNT = pWordsList1->size();
	const size_t DST_WORDS_COUNT = pWordsList2->size();
	int nPos = 0;

	for (size_t i = 0; i < SRC_WORDS_COUNT; i++)
	{
		if (!(*pWordsList1)[i]->GetExclude())
		{
			bool bFound = false;

			for (; nPos < DST_WORDS_COUNT; nPos++)
			{
				if ((*pWordsList1)[i]->GetWord() == (*pWordsList2)[nPos]->GetWord())
				{
					bFound = true;
					break;
				}
			}

			if (bFound)
			{
				if (i + 1 == SRC_WORDS_COUNT)
				{
					bMatch = true;
				}
			}
			else
			{
				break;
			}
		}
		else
		{
			if (i + 1 == SRC_WORDS_COUNT)
			{
				bMatch = true;
			}
		}
	}

	return bMatch;
}

//--------------------------------------------------------------------------------
/// <summary>
/// 添加新的模式
/// </summary>
/// <param name="refModel">新的模式</param>
/// <created>Andy,2020/6/10</created>
/// <changed>Andy,2020/6/10</changed>
//--------------------------------------------------------------------------------
bool CSLCTLogParser::AppendModel(const std::string & refModel, CWordsListPtr pWordsList)
{
	std::lock_guard<std::recursive_mutex> objLocker(m_objMutex);

	if (m_mapModelList.size() > MODE_COUNT_MAX)
	{
		return false;
	}

	bool bResult = true;

	if (m_mapModelList.size() > 0)
	{
		auto itr = m_mapModelList.find(refModel);

		if (m_mapModelList.end() == itr)
		{
			bool bMatch = false;
			auto itrMode = m_mapModelList.begin();

			for (; m_mapModelList.end() != itrMode; itrMode++)
			{
				CWordsListPtr pCurWordsList = (*itrMode).second;

				if (!(*pWordsList)[0]->GetExclude() && !(*pCurWordsList)[0]->GetExclude()
					&& (*pWordsList)[0]->GetWord() == (*pCurWordsList)[0]->GetWord())
				{
					bMatch = CheckContainModel(pWordsList, pCurWordsList);

					if (bMatch)
					{
						// 原来模式被包含于当前的模式,所以删除
						static_cast<CServerApp*>(GetTheApp())->RemoveLogModel((*itrMode).first);
						m_mapModelList.erase(itrMode);
						bResult = true;
						break;
					}
					else
					{
						bMatch = CheckContainModel(pCurWordsList, pWordsList);

						if (bMatch)
						{
							bResult = false;
							break;
						}
					}
				}
			}
		}
		else
		{
			bResult = false;
		}
	}


	if (bResult)
	{
		m_mapModelList[refModel] = pWordsList;
	}

	return bResult;
}



//--------------------------------------------------------------------------------
/// <summary>
/// 分析日志,挖掘模式
/// </summary>
/// <param name="refWord">被分析的日志行</param>
/// <created>Andy,2020/6/10</created>
/// <changed>Andy,2020/6/10</changed>
//--------------------------------------------------------------------------------
bool CSLCTLogParser::Parser(const std::string & refLogLine, std::string& refModel)
{
	bool bResult = false;
	CWordsListPtr pWordsList = std::make_shared<CWordsList>();

	CHECK_POINTER_EX(pWordsList, false);
	SplitWord(refLogLine, pWordsList);

	if (pWordsList->size() <= 0)
	{
		return bResult;
	}

#ifdef DEBUG
	//LOG_INFO("%s", "Begin");
#endif

	double nTotalFreq = 0;
	std::ostringstream  ossKey;
	int nIndex = 1;

	{
		std::lock_guard<std::recursive_mutex> objLocker(m_objMutex);

		for (CWordsStatPtr pWordsStat : *pWordsList)
		{
			ossKey << pWordsStat->GetWord() << nIndex;
			nIndex++;

			auto itr = m_mapWordsFreq.find(ossKey.str());

			if (itr != m_mapWordsFreq.end())
			{
				(*itr).second++;

				pWordsStat->SetFrequent((*itr).second);
			}
			else
			{
				m_mapWordsFreq[ossKey.str()] = 1;
				pWordsStat->SetFrequent(1);
			}

			nTotalFreq += pWordsStat->GetFrequent();
			ossKey.str("");

		}
	}


	int nAvgTotalFreq = nTotalFreq / pWordsList->size();

	if (nAvgTotalFreq > GetSampleThreshold())
	{
		//  重新计算总数,去除异常值的干扰
		int nNewTotalFreq = 0;

		for (CWordsStatPtr pWordsStat : *pWordsList)
		{
			if (pWordsStat->GetFrequent() > 2 * nAvgTotalFreq)
			{
				nNewTotalFreq += nAvgTotalFreq;
			}
			else
			{
				nNewTotalFreq += pWordsStat->GetFrequent();
			}
		}

		nTotalFreq = nNewTotalFreq;
		nAvgTotalFreq = nTotalFreq / pWordsList->size();

		std::map<int, int>    mapCount2Count;

		if (nAvgTotalFreq > GetSampleThreshold())
		{
			//  统计各个短语出现次数类别统计
			for (CWordsStatPtr pWordsStat : *pWordsList)
			{
				mapCount2Count[pWordsStat->GetFrequent()] += 1;
			}


			int nFrequent = 0;
			int nFrequentMaximal = 0;
			auto itr = mapCount2Count.begin();

			for (; mapCount2Count.end() != itr; itr++)
			{
				if ((*itr).second > nFrequentMaximal)
				{
					nFrequentMaximal = (*itr).second;
					nFrequent = (*itr).first;
				}
				else if ((*itr).second == nFrequentMaximal && (*itr).first > nFrequent)
				{
					nFrequentMaximal = (*itr).second;
					nFrequent = (*itr).first;
				}
			}


			bool bValid = true;

			if (nFrequentMaximal > 1)
			{
				if (nFrequent < GetSampleThreshold())
				{
					bValid = false;
				}
			}
			else
			{
				nFrequent = nAvgTotalFreq;	
			}

			if (bValid)
			{
				for (CWordsStatPtr pWordsStat : *pWordsList)
				{
					if (pWordsStat->GetFrequent() < nFrequent)
					{
						pWordsStat->SetExclude(true);
					}
				}

				CreateMode(refLogLine, pWordsList, refModel);

				bResult = AppendModel(refModel, pWordsList);
#ifdef DEBUG
				if (bResult)
				{
					for (CWordsStatPtr pWordsStat : *pWordsList)
					{
						LOG_INFO("%s: [BaseFreq:%d,CurFreq:%d,AvgFreq:%0.2f,%0.2f,%s]"
							, pWordsStat->GetWord().c_str()
							, nFrequent
							, pWordsStat->GetFrequent()
							, double(nAvgTotalFreq)
							, pWordsStat->GetFrequent() / double(nAvgTotalFreq)
							, pWordsStat->GetExclude() ? "去除" : "保留");

					}

					LOG_INFO("%s\r\n%s", refLogLine.c_str(), refModel.c_str());
				}
#endif
			}


		}
	}


	return bResult;
}
