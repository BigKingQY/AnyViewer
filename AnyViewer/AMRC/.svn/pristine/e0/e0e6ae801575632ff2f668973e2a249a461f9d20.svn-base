/////////////////////////////////////////////////////////////////////
/// @file SDPSnowflake.h
/// @brief 分布式id生成类
/// 
///https://segmentfault.com/a/1190000011282426
///https ://github.com/twitter/snowflake/blob/snowflake-2010/src/main/scala/com/twitter/service/snowflake/IdWorker.scala
///
///64bit id : 0000  0000  0000  0000  0000  0000  0000  0000  0000  0000  0000  0000  0000  0000  0000  0000
/// ||                                                           ||     ||     |  |              |
///| └-------------------------- - 时间戳--------------------------┘└中心 - ┘└机器 - ┘  └----序列号----┘
/// |
///不用
///SnowFlake的优点 : 整体上按照时间自增排序, 并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分), 并且效率较高, 经测试, SnowFlake每秒能够产生26万ID左右.
/// @author andy
/// @version 1
/// @date 2016-12-24
/////////////////////////////////////////////////////////////////////

#pragma once


#include <mutex>
#include <atomic>
#include <chrono>
#include <exception>
#include <sstream>
#include <boost/noncopyable.hpp>


class CSnowflakeIdWorker : private boost::noncopyable
{
public:
	typedef unsigned int UInt;
	typedef unsigned long long int UInt64;


	CSnowflakeIdWorker(UInt nWorkerId = 0, UInt nDatacenterId = 0)
		: m_nWorkerId(nWorkerId)
		, m_nDatacenterId(nDatacenterId)
		, m_nSeq(0)
		, m_nLastTimestamp(0)
	{
	}

public:
	void SetWorkerId(UInt nWorkerId) 
	{
		this->m_nWorkerId = nWorkerId;
	}

	void SetDatacenterId(UInt nDatacenterId)
	{
		this->m_nDatacenterId = nDatacenterId;
	}

	UInt64 GetId()
	{
		return GextId();
	}

	//--------------------------------------------------------------------------------
	/// <summary>
	/// 获得下一个ID (该方法是线程安全的)
	/// </summary>
	/// <returns>SnowflakeId</returns>
	/// <created>Andy,2019/12/30</created>
	/// <changed>Andy,2019/12/30</changed>
	//--------------------------------------------------------------------------------
	UInt64 GextId()
	{
		std::unique_lock<std::mutex> lock{ m_objMutex };
		UInt64 nTimestamp{ 0 };

		nTimestamp = TimeGen();

		// 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常
		if (nTimestamp < m_nLastTimestamp)
		{
			std::ostringstream s;
			s << "clock moved backwards.  Refusing to generate id for " << m_nLastTimestamp - nTimestamp << " milliseconds";
			throw std::exception(std::runtime_error(s.str()));
		}

		if (m_nLastTimestamp == nTimestamp)
		{
			// 如果是同一时间生成的，则进行毫秒内序列
			m_nSeq = (m_nSeq + 1) & SEQUENCE_MASK;

			if (0 == m_nSeq) 
			{
				// 毫秒内序列溢出, 阻塞到下一个毫秒,获得新的时间戳
				nTimestamp = tilNextMillis(m_nLastTimestamp);
			}
		}
		else 
		{
			m_nSeq = 0;
		}


		m_nLastTimestamp = 0/*nTimestamp*/;


		// 移位并通过或运算拼到一起组成64位的ID
		return ((nTimestamp - TWEPOCH) << TIMESTAMP_LEFT_SHIFT)
			| (m_nDatacenterId << DATA_CENTER_ID_SHIFT)
			| (m_nWorkerId << WORKER_ID_SHIFT)
			| m_nSeq;
	}

protected:
	//--------------------------------------------------------------------------------
	/// <summary>
	/// 返回以毫秒为单位的当前时间
	/// </summary>
	/// <returns>当前时间(毫秒)</returns>
	/// <created>Andy,2019/12/30</created>
	/// <changed>Andy,2019/12/30</changed>
	//--------------------------------------------------------------------------------
	UInt64 TimeGen() const 
	{
		auto t = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now());
		return t.time_since_epoch().count();
	}

	//--------------------------------------------------------------------------------
	/// <summary>
	/// 阻塞到下一个毫秒，直到获得新的时间戳
	/// </summary>
	/// <param name="lastTimestamp">上次生成ID的时间截</param>
	/// <returns>当前时间戳</returns>
	/// <created>Andy,2019/12/30</created>
	/// <changed>Andy,2019/12/30</changed>
	//--------------------------------------------------------------------------------
	UInt64 tilNextMillis(UInt64 lastTimestamp) const
	{
		UInt64 nTimestamp = TimeGen();
		
		while (nTimestamp <= lastTimestamp) 
		{
			nTimestamp = TimeGen();
		}

		return nTimestamp;
	}

private:
	std::mutex m_objMutex;

	///< 开始时间截 (2018-01-01 00:00:00.000)
	const UInt64 TWEPOCH = 1514736000000; 

	///< 机器id所占的位数
	const UInt WORKER_ID_BITS = 5;

	///< 数据中心id所占的位数
	const UInt DATA_CENTER_ID_BITS = 5;

	///< 序列所占的位数
	const UInt SEQUENCE_BITS = 12;

	///<  机器ID向左移12位
	const UInt WORKER_ID_SHIFT = SEQUENCE_BITS;

    ///< 数据标识id向左移17位
	const UInt DATA_CENTER_ID_SHIFT = WORKER_ID_SHIFT + WORKER_ID_BITS;

	///< 时间截向左移22位
	const UInt TIMESTAMP_LEFT_SHIFT = DATA_CENTER_ID_SHIFT + DATA_CENTER_ID_BITS;

	///< 支持的最大机器id，结果是31
	const UInt WORKER_ID_MAX = -1 ^ (-1 << WORKER_ID_BITS);

	///< 支持的最大数据中心id，结果是31
	const UInt DATA_CENTER_ID_MAX = -1 ^ (-1 << DATA_CENTER_ID_BITS);

	///<  生成序列的掩码，这里为4095
	const UInt SEQUENCE_MASK = -1 ^ (-1 << SEQUENCE_BITS);


	///<  工作机器id(0~31)
	UInt m_nWorkerId = 0;

	///< 数据中心id(0~31)
	UInt m_nDatacenterId = 0;

	///< 毫秒内序列(0~4095)
	UInt m_nSeq{ 0 };

	///< 上次生成ID的时间截
	UInt64 m_nLastTimestamp{ 0 };

};

typedef CSnowflakeIdWorker CIdWorker;

