/******************************************************************************
* 
* Miscellaneous Files
* Version
* Copyright (C) 2007 AxSoft Co., Ltd.
* All Rights Reserved
* $Header: /cvsdata/vc/Common/HttpClient.cpp,v 1.3 2015/08/17 01:03:48 administrator Exp $
* 
*******************************************************************************
* 
* Description:implements the TEAR console application
* note:connect 有可能会失败，从而导致注销失败，进一步引起天融信防火墙“达到最大用户”
******************************************************************************/
#include "stdafx.h"
// $Nokeywords: $

#include "HttpClient.h"
#include <openssl/err.h>
#include <boost/format.hpp>
#include <sys/socket.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>

const unsigned int TRY_COUNT_MAX = 50;
const unsigned int TRY_SLEEP_TIME = 1;

#define SOCKET_ERROR -1

/*---------------------------CHTTPRequestInfo-------------------*/

CHTTPRequestInfo::CHTTPRequestInfo()
	: m_strMothed("get")
	, m_strProtocolVer("HTTP/1.1")
{
}

CHTTPRequestInfo::CHTTPRequestInfo(LPCSTR lpMothed,LPCSTR lpURL, LPCSTR lpProtocolVer, LPCSTR lpBody)
	: m_strMothed(lpMothed)
	, m_strURL(lpURL)
	, m_strProtocolVer(lpProtocolVer)
	, m_strBody(lpBody)
{
}


CHTTPRequestInfo::~CHTTPRequestInfo()
{
}


CHTTPRequestInfo & CHTTPRequestInfo::AppendOption(LPCSTR lpName, LPCSTR lpValue)
{
	m_mapOptions[lpName] = lpValue;

	return *this;
}

//--------------------------------------------------------------------------------
/// <summary>
/// 组装http请求
/// </summary>
/// <created>Andy,2019/10/10</created>
/// <changed>Andy,2019/10/10</changed>
//--------------------------------------------------------------------------------
void CHTTPRequestInfo::Assemble()
{
	boost::format fmtCmd("%s %s %s\r\n");
	
	fmtCmd % m_strMothed % m_strURL % m_strProtocolVer;
	m_strRawData = fmtCmd.str();

	boost::format fmtContentLen("Content-Length: %u\r\n");

	fmtContentLen % m_strBody.size();
	m_strRawData += fmtContentLen.str();

	auto itr = m_mapOptions.begin();

	for (; m_mapOptions.end() != itr; itr++)
	{
		boost::format fmtOption("%s: %s\r\n");

		fmtOption % (*itr).first % (*itr).second;
		m_strRawData += fmtOption.str();
	}

	m_strRawData += "\r\n";
	m_strRawData += m_strBody;
}

void CHTTPRequestInfo::Clear()
{
	m_mapOptions.clear();
}



/*---------------------------CHTTPResponseInfo-------------------*/
CHTTPResponseInfo::CHTTPResponseInfo(LPCSTR lpOverTag)
	: m_nStatusCode(0)
	, m_strOverTag(lpOverTag)
{
}
CHTTPResponseInfo::~CHTTPResponseInfo()
{
}

void CHTTPResponseInfo::Analyze()
{
	m_nStatusCode = 0;

	enum ANALYSIS_STATUS
	{
		AS_INIT = 0,
		AS_STATUS = 1,       ///< 分析状态
		AS_OPTION = 2,       ///< 分析选项
	};

	bool bDone = false;
	std::string strOption;
	std::string strValue;
	ANALYSIS_STATUS nStatus = AS_INIT;
	const int DATA_LEN = m_strRawData.size();

	for (int i = 0; i < DATA_LEN && !bDone; i++)
	{
		const char chCur = m_strRawData.at(i);

		switch (nStatus)
		{
		case AS_INIT:
		{
			if (' ' == chCur)
			{
				nStatus = AS_STATUS;
				strValue.clear();
			}
			else if (':' == chCur)
			{
				nStatus = AS_OPTION;
				strValue.clear();
			}
			else if ('\r' == chCur)
			{
				bDone = true;
			}
			else
			{
				strOption += chCur;
			}
		}
		break;

		case AS_STATUS:
		{
			if (' ' == chCur)
			{
				m_nStatusCode = std::atoi(strValue.c_str());
			}
			else if ('\n' == chCur)
			{
				strValue.clear();
				strOption.clear();
				nStatus = AS_INIT;
			}
			else
			{
				strValue += chCur;
			}
		}
		break;

		case AS_OPTION:
		{
			if ('\r' == chCur)
			{
				m_mapOptions[strOption] = strValue;
			}
			else if ('\n' == chCur)
			{
				strValue.clear();
				strOption.clear();
				nStatus = AS_INIT;
			}
			else
			{
				strValue += chCur;
			}
		}
		break;
		}

	}

}

//--------------------------------------------------------------------------------
/// <summary>
/// 得到指定的属性值
/// </summary>
/// <param name="strOption">属性的名称</param>
/// <param name="strValue">属性的值</param>
/// <created>Andy,2019/11/8</created>
/// <changed>Andy,2019/11/8</changed>
//--------------------------------------------------------------------------------
void CHTTPResponseInfo::GetOptionValue(
	const std::string& strOption
	, std::string& strValue)
{
	strValue.clear();

	auto itr = m_mapOptions.find(strOption);

	if (m_mapOptions.end() != itr)
	{
		strValue = (*itr).second;
	}	
}

void CHTTPResponseInfo::Clear()
{
	m_nStatusCode = 0;
	m_strRawData.clear();
	m_mapOptions.clear();
}

//--------------------------------------------------------------------------------
/// <summary>
/// 得到应答正文
/// </summary>
/// <param name="strBody"></param>
/// <created>Andy,2019/11/6</created>
/// <changed>Andy,2019/11/6</changed>
//--------------------------------------------------------------------------------
void CHTTPResponseInfo::GetBody(std::string & strBody)
{
	std::size_t nStartPos = m_strRawData.find("\r\n\r\n");

	if (m_strRawData.npos != nStartPos)
	{
		nStartPos += 4;
		strBody = m_strRawData.substr(nStartPos, m_strRawData.size() - nStartPos);
	}
}

/*---------------------------CHTTPResponseInfo-------------------*/
CHTTPClient::CHTTPClient()
	: m_pSocket(0)
	, m_nIP(0)
	, m_nPort(0)
	, m_bEnableSSL(false)
	, m_pSSL(nullptr)
	, m_pSSLCtx(nullptr)
	, m_pBIO(nullptr)
{
}

CHTTPClient::~CHTTPClient()
{
	Disconnect();
}

/*-----------------------------------------------------------------
|  函数名称  : CHTTPClient::Init
|  描    述  : 初始化
|  参    数  : unsigned int nIP――目标服务器IP地址
|  参    数  : unsigned int nPort――端口
|  参    数  : bool bEnableSSL――是否采用加密传输
|  返 回 值  : true----successful
|              false---fail 
|  修改记录  : 2007-10-15 11:41:36   -huangdy-   创建
-----------------------------------------------------------------*/

bool CHTTPClient::Init(unsigned int nIP,unsigned int nPort,bool bEnableSSL)
{
	if(0 == nIP || 0 == nPort)
	{
		return false;
	}

	m_nIP        = nIP;
	m_nPort      = nPort;
	m_bEnableSSL = bEnableSSL;

	if(m_bEnableSSL && nullptr == m_pSSL)
	{
		OPENSSL_init();
		/*
	 * OPENSSL_init_ssl() may leave errors in the error queue
	 * while returning success
	 */

		ERR_clear_error();

		m_pSSLCtx = SSL_CTX_new(DTLS_client_method());

		if(nullptr == m_pSSLCtx)
		{
			return false;
		}

		SSL_CTX_set_quiet_shutdown(m_pSSLCtx,1); 
		SSL_CTX_set_options(m_pSSLCtx,SSL_OP_ALL);
		m_pBIO = BIO_new_ssl_connect(m_pSSLCtx);

		if(nullptr == m_pBIO)
		{
			return false;
		}

		BIO_get_ssl(m_pBIO, & m_pSSL);

		if(m_pSSL)
		{
			SSL_set_mode(m_pSSL, SSL_MODE_AUTO_RETRY);
		}

		SetRuning(true);
	}

	return true;
}

/*-----------------------------------------------------------------
|  函数名称  : CHTTPClient::Connect
|  描    述  : 连接到服务器
|  返 回 值  : true----successful
|              false---fail 
|  修改记录  : 2007-10-15 11:41:36   -huangdy-   创建
-----------------------------------------------------------------*/
bool CHTTPClient::Connect()
{
	bool bResult = false;

	if(!m_bEnableSSL)
	{
		if (-1 != m_pSocket)
		{
			close(m_pSocket);
		}

		m_pSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

		if(-1 == m_pSocket)
		{
			return false;
		}

		struct sockaddr_in server_addr;

		server_addr.sin_family      = AF_INET;
		server_addr.sin_addr.s_addr = htonl(m_nIP);
		server_addr.sin_port        = htons((unsigned int)m_nPort);
		bResult = (0 == connect(m_pSocket, (struct sockaddr *)&server_addr, sizeof(server_addr)));

		struct timeval objTimeout = { 5,0 };   //10s
		
		setsockopt(m_pSocket, SOL_SOCKET, SO_RCVTIMEO, (const char*)&objTimeout, sizeof(objTimeout));
	}
	else
	{		
		char  szBufferAnsi[32] = {0};
		AIM::CString strDestHost;
		strDestHost.Format("%s:%u",FormatHostIPAddressAnsi(m_nIP,szBufferAnsi),m_nPort);
		
		if (BIO_CLOSE == BIO_get_close(m_pBIO))
		{
			int nTryCount = 0;

			do
			{
				BIO_reset(m_pBIO);
				BIO_set_conn_hostname(m_pBIO, (LPCSTR)strDestHost);
				BIO_set_nbio(m_pBIO, 1);
				
				int fdSocket = 0;
				int nRet = BIO_do_connect(m_pBIO);

				if (nRet <= 0)
				{
					if (BIO_should_retry(m_pBIO))
					{
						if (BIO_get_fd(m_pBIO, &fdSocket) > 0)
						{
							struct timeval timeout;
							fd_set connectionfds;

							FD_ZERO(&connectionfds);
							FD_SET(fdSocket, &connectionfds);

							timeout.tv_usec = 0;
							timeout.tv_sec = 3;

							nRet = select(fdSocket + 1, nullptr, &connectionfds, nullptr, &timeout);
							bResult = (nRet > 0);
						}
					}
				}

				nTryCount++;
			} while (!bResult && nTryCount <= 5);
		}
	}

	return bResult;
}

/*-----------------------------------------------------------------
|  函数名称  : CHTTPClient::Disconnect
|  描    述  : 断开连接
|  返 回 值  : true----successful
|              false---fail 
|  修改记录  : 2007-10-15 11:41:36   -huangdy-   创建
-----------------------------------------------------------------*/

bool CHTTPClient::Disconnect()
{
	if(m_bEnableSSL)
	{
		SSL_CTX_free(m_pSSLCtx);
		BIO_free(m_pBIO);

		m_pBIO    = nullptr;
		m_pSSLCtx = nullptr;

		//ERR_free_strings();
	}
	else
	{
		if(-1 != m_pSocket)
		{
			close(m_pSocket);
			m_pSocket = -1;
		}
	}

	return true;
}



/*-----------------------------------------------------------------
|  函数名称  : CHTTPClient::SendData
|  描    述  : 发送受数据到服务器接
|  参    数  : std::string& strMsg――被发送的数据
|  返 回 值  : true----successful
|              false---fail 
|  修改记录  : 2007-10-15 11:41:36   -huangdy-   创建
-----------------------------------------------------------------*/

bool CHTTPClient::SendData(std::string strMsg)
{
	bool bResult = false;
	const size_t CONTENT_LEN = strMsg.size();
	size_t nTotalBytesSent   = 0;
	int nBytesSent        = 0;
	const char* pContent  = strMsg.c_str();

	if(!m_bEnableSSL)
	{
		assert(m_pSocket >= 0);

		if(m_pSocket >= 0)
		{
			do
			{
				nBytesSent = send(m_pSocket, pContent + nTotalBytesSent, std::min(1024,int(CONTENT_LEN - nTotalBytesSent)), 0);

				if(SOCKET_ERROR == nBytesSent)
				{
					break;
				}

				nTotalBytesSent += nBytesSent;

			}while(nTotalBytesSent < CONTENT_LEN);
		}
	}
	else
	{
		unsigned int nTryCount = 0;

		do
		{
			const int nBytesSent = BIO_write(m_pBIO, strMsg.c_str(), CONTENT_LEN);

			if (nBytesSent > 0)
			{
				nTotalBytesSent += nBytesSent;
			}
			else
			{
				nTryCount++;

				if (BIO_should_retry(m_pBIO))
				{
					sleep(TRY_SLEEP_TIME);
				}
			}

		} while (nTotalBytesSent < CONTENT_LEN && nTryCount < TRY_COUNT_MAX && GetRuning());
	}	

	bResult = (CONTENT_LEN == nTotalBytesSent);

	return bResult;
}

const	unsigned int BUFFER_SIZE = 1024 * 4;

/*-----------------------------------------------------------------
|  函数名称  : CHTTPClient::RecvData
|  描    述  : 从服务器接受数据
|  参    数  : std::string& strResponseText――存储接受的数据
|  返 回 值  : true----successful
|              false---fail 
|  修改记录  : 2007-10-15 11:41:36   -huangdy-   创建
-----------------------------------------------------------------*/

bool CHTTPClient::RecvData(std::string& strResponseText, CHTTPResponseInfo& objResponseInfo)
{
	int nTotalBytesRecved            = 0;

	strResponseText.clear();
	int nRecvBytes            = 0;
	char szResposeBuffer[BUFFER_SIZE] = {0};

	if(!m_bEnableSSL)
	{
		assert(m_pSocket >= 0);

		if(m_pSocket >= 0)
		{
			bool nLenExtracted = false;   ///< 内容的长度是否已经被提取
			int nContentLen = 1024;

			do
			{
				nRecvBytes = recv(m_pSocket, szResposeBuffer, sizeof(szResposeBuffer), 0);

				if(SOCKET_ERROR == nRecvBytes)
				{
					break;
				}

				strResponseText += std::string(szResposeBuffer,nRecvBytes);
				nTotalBytesRecved += nRecvBytes;

				if (!nLenExtracted && nTotalBytesRecved > 0)
				{
					if (Ax3_stristr_ansi(strResponseText.c_str()
						, objResponseInfo.GetOverTag().c_str()) != nullptr)
					{
						std::string strLen;
						CHTTPResponseInfo objResponseInfo;

						objResponseInfo.SetRawData(strResponseText);
						objResponseInfo.Analyze();
						objResponseInfo.GetOptionValue("Content-Length", strLen);

						if (strLen.size() > 0)
						{
							nContentLen = std::atoi(strLen.c_str());
							nLenExtracted = true;
						}
					}
				}

			}while(	nRecvBytes > 0 && nTotalBytesRecved < nContentLen);
		}
	}
	else
	{
		unsigned int nTryCount = 0;

		do
		{      
			nRecvBytes = BIO_read(m_pBIO, szResposeBuffer, BUFFER_SIZE);

			if (nRecvBytes > 0)
			{
				nTotalBytesRecved += nRecvBytes;
				strResponseText += std::string(szResposeBuffer, nRecvBytes);

				if (Ax3_stristr_ansi(strResponseText.c_str(), objResponseInfo.GetOverTag().c_str()) != nullptr)
				{
					break;
				}
			}
			else
			{
				nTryCount++;

				if (BIO_should_retry(m_pBIO))
				{
					sleep(TRY_SLEEP_TIME);
				}
			}

		}while (nTryCount < TRY_COUNT_MAX && GetRuning());
	}

	return (nTotalBytesRecved > 0);
}

/*-----------------------------------------------------------------
|  函数名称  : CHTTPClient::PostHTTPRequest
|  描    述  : 提交命令到web服务器，注意每次需要重新连接，http协议规定的
|  参    数  : CHTTPRequestInfo& objRequestInfo――请求信息对象参考
|  参    数  : CHTTPResponseInfo& objResponseInfo――返回信息对象参考
|  返 回 值  : >0----successful
|              0<---fail (-1:无法连接,-2:发送失败,-3:接受失败)
|  修改记录  : 2007-10-15 11:41:36   -huangdy-   创建
-----------------------------------------------------------------*/

int CHTTPClient::PostHTTPRequest(CHTTPRequestInfo& objRequestInfo
	,CHTTPResponseInfo& objResponseInfo)
{
	int bResult = -1;
	std::lock_guard<std::mutex>   objAutoLock(m_csLock);
	objResponseInfo.Clear();

	if (Connect())
	{
		if(SendData(objRequestInfo.GetRawData().c_str()))
		{
			std::string strResult;

			if(RecvData(strResult, objResponseInfo))
			{
				objResponseInfo.SetRawData(strResult);	
				objResponseInfo.Analyze();
				bResult = 1;
			}
			else
			{
				bResult = -3;
			}
		}
		else
		{
			bResult = -2;
		}

		BIO_reset(m_pBIO);
	}
	
	//assert(bResult > 0);

	return bResult;
}