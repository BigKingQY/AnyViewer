/////////////////////////////////////////////////////////////////////
/// @file VNCProxy.h
/// @brief 虚拟网络控制台类定义
/// 
///主要有连个功能:1.发送视频数据到控制计算机,2.接收控制计算机发送来的控制命令
/// vnc RBF 协议:https://www.cnblogs.com/szBeginner/p/7887686.html
/// @author andy
/// @version 1
/// @date 2020-11-26
/////////////////////////////////////////////////////////////////////

#pragma once
#include "VNCEndpoint.h"
#include "RCProtocol.h"
#include "VNCServer.h"
#include "VNCClient.h"
#include "RCServerProxy.h"
#include "Dimension.h"


class CPixelFormat;
struct Point;
class Rect;

class CVNCProxy :public CNetEndpointEventSink
	,public std::enable_shared_from_this<CVNCProxy>
{
public:
	CVNCProxy(const U32 nSessionID = 0
		, const U32 nPeerID = 0
		, const U32 nPeerIP = 0
		, const U16 nPeerPort = 0
		, const U32 nCommunicationMode = 0
		, const U32 nRoleType = RCP::RCT_CONTROLLER
		, const unsigned int nProtocolVer = RCP::PV_FIRST);
	~CVNCProxy();

public:
	double GetReceivingLasttime();

	double GetConnecitonTime();

	CONVERSATION_STATE GetConversationStatus();

	// 得到连接持续的时间(单位:藐视)
	double GetDurationTime() {	return m_objDuration.elapsed();	}
public:
	// 启动代理
	bool Start();

	// 发送简单的请求消息
	bool SendCommonRequest(const unsigned int nType);

	// 发送简单的应答消息
	bool SendCommonResponse(const unsigned int nType);

	// 发Hello请求
	bool SendHelloRequest();

	// 发送客户端初始化
	bool SendClientInit(const U8 nSharedFlag,const U8 nHideWallPage, const U8 nImageQuality);

	// 发送客户端设置（主要是画面质量和桌面壁纸）
	bool SendClientSettings(const U8 nHideWallPage, const U8 nImageQuality);

	// 发送初始化消息
	bool SendReadyRequest(const U8 nResponse = 0);

	// 发送更新帧缓冲区请求
	bool SendFBUpdateRequest(const bool bIncremental, const Rect& refUpdateRect);

	// 发送更新帧缓冲区请求
	bool SendPixelFormatUpdateRequest(const CPixelFormat& refPixelFormat);
	
	// 发送键盘事件请求
	bool SendKeyboardEventRequest(const bool bDownFlag, const UINT32 nKey);

	// 发送鼠标事件请求
	bool SendPointerEventRequest(const UINT8 nButtonMask, const Point& refPosition);

	// 发送剪切文本事件请求
	bool SendCutTextEventRequest(const std::string& refCutText);

	// 服务端发送客户端，禁止或启用用户输入控制
	bool SendEnableInputRequest(const bool bEnableCtrl);

	// 发送一个帧数据
	bool SendFrameData(const BYTE* pData, const unsigned int nLen);

	// 发送帧缓冲区属性
	void SendFrameProperty(const CSize& refDim, const CPixelFormat& refPixelFormat);

	// 设置新的帧缓冲区的尺寸
	void SendFrameBufSize(const CSize* pDim);
	
	// 发送帧缓冲区像素格式
	void SendFramePixelFormat(const CPixelFormat& refPixelFormat);

	// 发送操作系统属性
	bool SendOSInfo(const VNCP::COSInfo& refOSInfo);

	// 发送当前会话状态到控制端
	bool SendSessionStateRequest(const unsigned int nState);

	// 发送改变被控制计算分辨率的请求
	bool SendChangingResolutionRequest(const VNCP::CDevMode& refDevMode);

	// 发送数据包
	bool Send(CNetPacket* pPacket);

	// 发送数据
	bool Send(const BYTE* pData, const unsigned int nLen);

	

	bool Flush();

	// 准备关闭当前VNC代理
	bool PreClose();

	// 关闭当前VNC代理
	bool Close();

	// 注册到信使服务器
	bool RegistUDPHoleServer();

	// 采用UDP连接到目标设备
	bool UDPConnect(const unsigned int nIP, const unsigned int nPort);

public:
	bool OnEventHandle(PTR_NET_ENDPOINT_INTERFACE pEndpoint, SEVERITY_LEVEL nSeverity, SERVICE_EVENT nEvent, LPCTSTR lpTips);

	// 成功建立通道事件
	void OnEstablished();
private:
	// 采用TCP连接到目标设备
	bool TCPConnect();


private:
	DECLARE_MEMBER_AND_METHOD_V11(U32, m_nSessionID, SessionID, 0)               ///< 会话ID
	DECLARE_MEMBER_AND_METHOD_V11(U64, m_nPeerID, PeerID, 0)                     ///< 对端ID
	DECLARE_MEMBER_AND_METHOD_V11(U32, m_nPeerIP, PeerIP, 0)                     ///< 对端IP
	DECLARE_MEMBER_AND_METHOD_V11(U32, m_nPeerPort, PeerPort, 0)                 ///< 得到对端端口
	DECLARE_MEMBER_AND_METHOD_V11(U32, m_nCommunicationMode, CommunicationMode, RCP::ST_HOLE)     ///< 会话类型
	DECLARE_MEMBER_AND_METHOD_V11(U32, m_nRoleType, RoleType, RCP::RCT_CONTROLLER)    ///< 角色类型,@see RC_CLIENT_TYPE
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nProtocolVer, ProtocolVer, 0); ///< 会话锁采用的协议版本号

	// 远程控制服务代理
	DECLARE_MEMBER_AND_METHOD_V11(CRCSvrProxyPtr, m_pRCSvrProxy, RCSvrProxy, nullptr);

	 ///< 当前的代理用于通信的端点对象
	DECLARE_MEMBER_AND_METHOD_V11(PTR_NET_ENDPOINT_INTERFACE, m_pEndpoint, Endpoint, nullptr);

	///< 当前的代理用于通信的TCP客户端对象
	DECLARE_MEMBER_AND_METHOD_V11(CVNCTCPClientPtr, m_pVNCTCPClient, VNCTCPClient, nullptr);

	///< 当前的代理用于通信的TCP客户端对象
	DECLARE_MEMBER_AND_METHOD_V11(CVNCUDPClientPtr, m_pVNCUDPClient, VNCUDPClient, nullptr);

	///< 正确被关闭标志
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bClosing, Closing, false);	

	///< 是否正确建立连接
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bEstablishVNCConnection, EstablishVNCConnection, false);

	DECLARE_MEMBER_AND_METHOD(std::string, m_strNickName, NickName)          ///< 名称	

	///< 正在关闭,控制段或被控制端的用户点击了关闭会话按钮
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bProactiveClosing, ProactiveClosing,false)

	///< 控制端发送来的隐藏桌面设置
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bHideWallPage, HideWallPage, true);

	///< 控制端发送来图形质量类型设置,@see IMAGE_QUALITY_TYPE
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nImageQuality, ImageQuality, 0);

	CVNCPacket                  m_objFrameRequestPacket;

	// 连接持续时间
	boost::timer              m_objDuration;

	// 采用的屏幕分辨率
	DECLARE_MEMBER_AND_METHOD(CSize, m_objScreanSize, ScreanSize);	

	// 刚建立控制通道时被控端的屏幕分辨率
	DECLARE_MEMBER_AND_METHOD(CSize, m_objOriginalScreanSize, OriginalScreanSize);

	///<  被控制段操作系统类型，@see CEnvironment::OS_VERSION
	DECLARE_MEMBER_AND_METHOD_V11(U32, m_nControlledOS, ControlledOS, 0)

	/// < 被控制段当前会话的状态
	DECLARE_MEMBER_AND_METHOD_V11(UINT, m_nControlledSessionState, ControlledSessionState, WTS_SESSION_LOGON);

	///< 是否已经收到第一个数据包
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bFirstPacketRecivied, FirstPacketRecivied, false);

	///<  被控制端软件版本号
	DECLARE_MEMBER_AND_METHOD_V11(U32, m_nVersion, Version, 0);
};

using CVNCProxyPtr = std::shared_ptr<CVNCProxy>;
using CVNCProxyArray = std::vector<CVNCProxyPtr>;
