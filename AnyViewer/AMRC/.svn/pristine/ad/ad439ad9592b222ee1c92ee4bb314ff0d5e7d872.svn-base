#pragma once

#include "CommonHeader.h"

class Rect;
using CRectArray = std::vector<Rect>;


class Rect
{
public:
	Rect(void) : left(0), top(0), right(0), bottom(0) {}
	Rect(const Rect *rect) { setRect(rect); }
	Rect(const Rect &rect) { setRect(&rect); }
	Rect(int lt, int tp, int rt, int bm) { setRect(lt, tp, rt, bm); }
	Rect(int width, int height) { setRect(0, 0, width, height); }
	Rect(const RECT *rect) { FromWindowsRect(rect); }

	virtual ~Rect(void) {}

	int left{0};
	int top{0};
	int right{0};
	int bottom{0};

	inline void setRect(int lt, int tp, int rt, int bm)
	{
		left = lt;
		top = tp;
		right = rt;
		bottom = bm;
	}

	inline void setRect(const Rect *rect)
	{
		left = rect->left;
		top = rect->top;
		right = rect->right;
		bottom = rect->bottom;
	}

	inline Rect & operator=(const Rect &rect)
	{
		setRect(&rect);
		return *this;
	}

	inline bool isValid() const
	{
		if (right < left || bottom < top)
		{
			return false;
		}
		return true;
	}

	inline bool isPointInRect(int pointX, int pointY)
	{
		if (pointX < left || pointX >= right)
		{
			return false;
		}

		if (pointY < top || pointY >= bottom)
		{
			return false;
		}
		return true;
	}

	// Return true this Rect fully contain the inner Rect, otherwise return false.
	inline bool isFullyContainRect(const Rect *inner)
	{
		if (inner->left < left || inner->top < top ||
			inner->right > right || inner->bottom > bottom)
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	// Convert to windows RECT
	inline RECT toWindowsRect() const
	{
		RECT winRect;
		winRect.left = left;
		winRect.top = top;
		winRect.right = right;
		winRect.bottom = bottom;
		return winRect;
	} const

		// Load from windows RECT
		inline void FromWindowsRect(const RECT *winRect)
	{
		left = winRect->left;
		top = winRect->top;
		right = winRect->right;
		bottom = winRect->bottom;
	}

	inline void move(int offsetX, int offsetY)
	{
		left += offsetX;
		right += offsetX;
		top += offsetY;
		bottom += offsetY;
	}

	inline void SetLocation(int destX, int destY)
	{
		int offsetX = destX - left;
		int offsetY = destY - top;
		left = destX;
		right += offsetX;
		top = destY;
		bottom += offsetY;
	}

	inline bool IsEqualTo(const Rect *rect)  const {
		return  rect->left == left &&
			rect->top == top &&
			rect->right == right &&
			rect->bottom == bottom;
	}

	inline void setWidth(int value) { right = left + value; }
	inline void setHeight(int value) { bottom = top + value; }

	inline int getWidth()  const { return right - left; }
	inline int getHeight() const { return bottom - top; }

	void rotateOn90InsideDimension(int dimHeight)
	{
		Rect localCopy(this);
		setWidth(localCopy.getHeight());
		setHeight(localCopy.getWidth());
		int newLeft = dimHeight - localCopy.top - localCopy.getHeight();
		int newTop = localCopy.left;
		SetLocation(newLeft, newTop);
	}

	void rotateOn180InsideDimension(int dimWidth, int dimHeight)
	{
		int newLeft = dimWidth - left - getWidth();
		int newTop = dimHeight - top - getHeight();
		SetLocation(newLeft, newTop);
	}

	void rotateOn270InsideDimension(int dimWidth)
	{
		Rect localCopy(this);
		setWidth(localCopy.getHeight());
		setHeight(localCopy.getWidth());
		int newLeft = localCopy.top;
		int newTop = dimWidth - localCopy.left - localCopy.getWidth();
		SetLocation(newLeft, newTop);
	}

	inline bool IsEmpty() const { return getWidth() <= 0 || getHeight() <= 0; }
	inline int Area() const { return IsEmpty() ? 0 : getWidth() * getHeight(); }

	static int totalArea(CRectArray &v) {
		int area = 0;
		for (CRectArray::iterator i = v.begin(); i < v.end(); i++)
			area += i->Area();
		return area;
	}

	inline void Clear() { left = top = right = bottom = 0; }

	// ********************************************************************************
	/// <summary>
	/// 计算与其它区域的交集
	/// </summary>
	/// <param name="other"></param>
	/// <returns></returns>
	/// <created>Andy,2020/9/27</created>
	/// <changed>Andy,2020/9/27</changed>
	// ********************************************************************************
	Rect Intersection(const Rect *other) const
	{
		Rect result;

		result.setRect((left > other->left) ? left : other->left,
			(top > other->top) ? top : other->top,
			(right < other->right) ? right : other->right,
			(bottom < other->bottom) ? bottom : other->bottom);

		if (!result.isValid())
		{
			result.Clear();
		}
		return result;
	}
};




