///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  
/// @brief 数据库连接池实现
/// 
///
/// @author 黄丽云
/// @version 1.0
/// @date        2020-3-29
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DBConnPool.h"
#include "log.h"

#include <iostream>
#include <stdexcept>  
#include <exception>  
#include <stdio.h>  



CDBConnPool::~CDBConnPool()
{
	DestoryConnPool();
}

CDBConnPool* CDBConnPool::s_pInstance = nullptr;

//--------------------------------------------------------------------------------
/// <summary>
/// Singleton: get the single object
/// </summary>
/// <returns>成功返回指向连接池对象的指针</returns>
/// <created>Andy,2020/3/26</created>
/// <changed>Andy,2020/3/26</changed>
//--------------------------------------------------------------------------------
CDBConnPool* CDBConnPool::GetInstance()
{
	if (nullptr == s_pInstance)
	{
		s_pInstance = new CDBConnPool;
	}

	return s_pInstance;
}

//--------------------------------------------------------------------------------
/// <summary>
/// Destroy the connection pool Instance
/// </summary>
/// <created>Andy,2020/3/26</created>
/// <changed>Andy,2020/3/26</changed>
//--------------------------------------------------------------------------------
void CDBConnPool::DestorInstance()
{
	if (nullptr != s_pInstance)
	{
		delete s_pInstance;
		s_pInstance = nullptr;
	}
}


//--------------------------------------------------------------------------------
/// <summary>
/// init pool
/// </summary>
/// <param name="strURL">数据库的地址,比如:tcp://127.0.0.1:3306</param>
/// <param name="strUser">登录数据的名称</param>
/// <param name="strPwd">密码</param>
/// <param name="nMaxSize">初始化连接个数</param>
/// <returns></returns>
/// <created>Andy,2020/3/26</created>
/// <changed>Andy,2020/3/26</changed>
//--------------------------------------------------------------------------------
bool CDBConnPool::InitPool(
	const std::string& strURL
	, const std::string& strUser
	, const std::string& strPwd
	, const int nMaxSize)
{
	bool bResult = false;

	m_strUser = strUser;
	m_strPassword = strPwd;
	m_strURL = strURL;
	m_nMaxSize = nMaxSize;
	m_nCurSize = 0;

	if (m_nMaxSize < 0)
	{
		m_nMaxSize = 2;
	}

	try 
	{
		m_nDriver = sql::mysql::get_driver_instance();	

		if (nullptr != m_nDriver)
		{
			bResult = (InitConnection(nMaxSize) > 0);
		}
	}
	catch (sql::SQLException& e)
	{
		std::cout << e.what() << std::endl;
	}
	catch (std::runtime_error& e)
	{
		std::cout << e.what() << std::endl;
	}

	return bResult;
}

//--------------------------------------------------------------------------------
/// <summary>
/// init conn pool
/// </summary>
/// <param name="initSize"></param>
/// <returns></returns>
/// <created>Andy,2020/3/26</created>
/// <changed>Andy,2020/3/26</changed>
//--------------------------------------------------------------------------------
int CDBConnPool::InitConnection(const unsigned int initSize)
{	
	LOG_INFO("URL:%s\r\nAccount:%s", m_strURL.c_str(), m_strUser.c_str());
	std::lock_guard<std::recursive_mutex> objAutoLock(m_objlock);

	for (int i = 0; i < initSize; i++)
	{
		sql::Connection*  pConn = CreateConnection();

		if (nullptr != pConn)
		{
			m_lstConnctions.push_back(pConn);			
		}
		else
		{
			LOG_INFO("Fail to create a new connection!");
		}
	}

	return m_lstConnctions.size();
}

//--------------------------------------------------------------------------------
/// <summary>
/// 
/// </summary>
/// <returns></returns>
/// <created>Andy,2020/3/26</created>
/// <changed>Andy,2020/3/26</changed>
//--------------------------------------------------------------------------------
sql::Connection* CDBConnPool::CreateConnection()
{
	sql::Connection* pResult = nullptr;
	
	try 
	{
		pResult = m_nDriver->connect(m_strURL, m_strUser, m_strPassword);  //create a conn 
	}
	catch (sql::SQLException& e)
	{
		LOG_INFO("%s",e.what());
	}
	catch (std::runtime_error& e)
	{
		LOG_INFO("%s", e.what());
	}

	return pResult;
}

//--------------------------------------------------------------------------------
/// <summary>
/// 
/// </summary>
/// <returns></returns>
/// <created>Andy,2020/3/26</created>
/// <changed>Andy,2020/3/26</changed>
//--------------------------------------------------------------------------------
sql::Connection* CDBConnPool::GetConnection()
{
	std::lock_guard<std::recursive_mutex> objAutoLock(m_objlock);
	sql::Connection* pResult = nullptr;	

	if (m_lstConnctions.size() > 0)  //the pool have a pResult 
	{
		pResult = m_lstConnctions.front();
		m_lstConnctions.pop_front(); //move the first pResult 

		if (pResult->isClosed()	|| !pResult->isValid())    //if the pResult is closed, delete it and recreate it
		{
			pResult->reconnect();
		}		

		return pResult;
	}
	else
	{
		if (m_nCurSize < m_nMaxSize)//the pool no pResult
		{
			pResult = CreateConnection();

			if (nullptr != pResult)
			{
				++m_nCurSize;
			}
		}
	}

	return pResult;

}

//--------------------------------------------------------------------------------
/// <summary>
/// put conn back to pool
/// </summary>
/// <param name="pConn">一个指向连接对象的指针</param>
/// <created>Andy,2020/3/26</created>
/// <changed>Andy,2020/3/26</changed>
//--------------------------------------------------------------------------------
void CDBConnPool::ReleaseConnection(sql::Connection *pConn)
{
	if (pConn)
	{
		std::lock_guard<std::recursive_mutex> objAutoLock(m_objlock);

		m_lstConnctions.push_back(pConn);
	}
}

//--------------------------------------------------------------------------------
/// <summary>
/// 释放整个连接池
/// </summary>
/// <created>Andy,2020/3/26</created>
/// <changed>Andy,2020/3/26</changed>
//--------------------------------------------------------------------------------
void CDBConnPool::DestoryConnPool()
{
	std::lock_guard<std::recursive_mutex> objAutoLock(m_objlock);	

	for (auto pConn: m_lstConnctions)
	{
		DestoryConnection(pConn);
	}

	m_lstConnctions.clear();
	m_nCurSize = 0;		
}


//--------------------------------------------------------------------------------
/// <summary>
/// destory a connection
/// </summary>
/// <param name="pConn">指向数据库连接的对象指针</param>
/// <created>Andy,2020/3/26</created>
/// <changed>Andy,2020/3/26</changed>
//--------------------------------------------------------------------------------
void CDBConnPool::DestoryConnection(sql::Connection* pConn)
{
	if (nullptr != pConn)
	{
		try 
		{
			pConn->close();
		}
		catch (sql::SQLException& e)
		{
			std::cout << e.what() << std::endl;
		}
		catch (std::runtime_error& e)
		{
			std::cout << e.what() << std::endl;
		}
		
		// 异常捕捉外释放才是正确的
		delete pConn;
	}
}

