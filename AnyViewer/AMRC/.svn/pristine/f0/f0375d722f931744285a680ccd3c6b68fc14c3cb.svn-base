#include "stdafx.h"
#include "JsonHelper.h"
#include "rapidjson/filereadstream.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*---------------------------CKeyValueList-------------------*/

//--------------------------------------------------------------------------------
/// <summary>
/// // 创建一个字段映射定义并设置其"type"属性（专用函数）
/// </summary>
/// <param name="lpName">字段名称</param>
/// <param name="lpType">类型</param>
/// <created>Andy,2020/4/5</created>
/// <changed>Andy,2020/4/5</changed>
//--------------------------------------------------------------------------------
std::shared_ptr<CKeyValueList> CKeyValueList::CreateFieldProp(
	const char* lpName
	, const char* lpType)
{
	std::shared_ptr<CKeyValueList> pResult = nullptr;
	std::shared_ptr<CKeyValue<CKeyValueList>> pFieldDef = std::make_shared<CKeyValue<CKeyValueList>>(
		lpName, std::make_shared<CKeyValueList>());

	if (nullptr != pFieldDef)
	{
		m_lstKeyValue.push_back(pFieldDef);
		pResult = pFieldDef->GetValue();

		if (nullptr != pResult)
		{
			pResult->CreateKV<std::string>("type", std::make_shared<std::string>(lpType));
		}
	}

	return pResult;
}

void CKeyValueList::Serialize(CJSONSerializer & refJsonSerializer) const
{
	CSerializeEntry::Serialize(refJsonSerializer);
	
	auto itr = m_lstKeyValue.begin();

	for (; m_lstKeyValue.end() != itr;itr++)
	{
		(*itr)->Serialize(refJsonSerializer);
	}
}

void CKeyValueList::DeSerialize(CJSONSerializer & refJsonSerializer)
{
	CSerializeEntry::DeSerialize(refJsonSerializer);
}

/*--------------------CJsonHelper------------------------------*/
CJsonHelper::CJsonHelper()
{
}


CJsonHelper::~CJsonHelper()
{

}
#ifdef WIN32

const NUM_TO_STR JSON_ERROR_MSG804[] =
{
	{rapidjson::kParseErrorDocumentEmpty,              _T("空文档")},
{rapidjson::kParseErrorDocumentRootNotSingular,       _T("文档根目录不能后跟其他值")},

{rapidjson::kParseErrorValueInvalid,                   _T("无效值")},

{rapidjson::kParseErrorObjectMissName,                _T("缺少对象成员的名称")},
{rapidjson::kParseErrorObjectMissColon,               _T("对象成员名称后缺少冒号")},
{rapidjson::kParseErrorObjectMissCommaOrCurlyBracket, _T("对象成员后缺少逗号或“}”")},

{rapidjson::kParseErrorArrayMissCommaOrSquareBracket,  _T("数组元素后缺少逗号或“]”")},

{rapidjson::kParseErrorStringUnicodeEscapeInvalidHex,  _T("字符串转义后的'\\u'十六进制数字不正确")},
{rapidjson::kParseErrorStringUnicodeSurrogateInvalid,  _T("字符串中的代理项对无效")},
{rapidjson::kParseErrorStringEscapeInvalid,            _T("字符串中的转义字符无效")},
{rapidjson::kParseErrorStringMissQuotationMark,        _T("字符串中缺少右引号")},
{rapidjson::kParseErrorStringInvalidEncoding,          _T("字符串中的编码无效")},

{rapidjson::kParseErrorNumberTooBig,                   _T("数字太大，不能存储在双精度中")},
{rapidjson::kParseErrorNumberMissFraction,             _T("缺少分数部分")},
{rapidjson::kParseErrorNumberMissExponent,             _T("缺少指数")},

{rapidjson::kParseErrorTermination,                    _T("分析已终止")},
{rapidjson::kParseErrorUnspecificSyntaxError,         _T("非特定语法错误")}
};


const NUM_TO_STR   JSON_ERROR_MSG409[] =
{
	{rapidjson::kParseErrorDocumentEmpty,              _T("The document is empty")},
{rapidjson::kParseErrorDocumentRootNotSingular,        _T("The document root must not follow by other values")},

{rapidjson::kParseErrorValueInvalid,                   _T("Invalid value")},

{rapidjson::kParseErrorObjectMissName,                _T("Missing a name for object member")},
{rapidjson::kParseErrorObjectMissColon,                _T("Missing a colon after a name of object member")},
{rapidjson::kParseErrorObjectMissCommaOrCurlyBracket, _T("Missing a comma or '}' after an object member")},

{rapidjson::kParseErrorArrayMissCommaOrSquareBracket,  _T("Missing a comma or ']' after an array element")},

{rapidjson::kParseErrorStringUnicodeEscapeInvalidHex,  _T("Incorrect hex digit after \\u escape in string")},
{rapidjson::kParseErrorStringUnicodeSurrogateInvalid,  _T("The surrogate pair in string is invalid")},
{rapidjson::kParseErrorStringEscapeInvalid,           _T("Invalid escape character in string")},
{rapidjson::kParseErrorStringMissQuotationMark,        _T("Missing a closing quotation mark in string")},
{rapidjson::kParseErrorStringInvalidEncoding,         _T("Invalid encoding in string")},

{rapidjson::kParseErrorNumberTooBig,                   _T("Number too big to be stored in double")},
{rapidjson::kParseErrorNumberMissFraction,             _T("Miss fraction part in number")},
{rapidjson::kParseErrorNumberMissExponent,             _T("Miss exponent in number")},

{rapidjson::kParseErrorTermination,                    _T("Parsing was terminated")},
{rapidjson::kParseErrorUnspecificSyntaxError,           _T("Unspecific syntax error")}
};

//--------------------------------------------------------------------------------
/// <summary>
/// 得到错误信息
/// </summary>
/// <param name="nLanguage">语言</param>
/// <param name="nErrCode">错误代码</param>
/// <returns>错误提示信息</returns>
/// <created>Andy,2020/4/15</created>
/// <changed>Andy,2020/4/15</changed>
//--------------------------------------------------------------------------------
CString CJsonHelper::GetErrMsg(
	const unsigned int nLanguage
	, const rapidjson::ParseErrorCode nErrCode)
{
	CString strResult;

	if (nLanguage == 0x804)
	{
		strResult = GetDescStr(JSON_ERROR_MSG804, nErrCode);
	}
	else if (nLanguage == 0x409)
	{
		strResult = GetDescStr(JSON_ERROR_MSG409, nErrCode);
	}

	return strResult;
}

//-----------------------------------------------------------------------------
///@brief解析json到dom中
///@param [inout]refDom-dom对象
///@param [in]lpFile-待解析的文件
///@author leiyz
///@date 20180712
//-----------------------------------------------------------------------------
bool CJsonHelper::Decode(rapidjson::Document & refDom, LPCTSTR lpFile)
{
    FILE* pFile = nullptr;
    bool bResult = false;

    if (0 == _tfopen_s(&pFile, lpFile, _T("rb")))
    {
        char readBuffer[4096] = { 0 };
        rapidjson::FileReadStream objFileReadStream(pFile, readBuffer, sizeof(readBuffer));
        refDom.ParseStream(objFileReadStream);
        if (pFile)
        {
            fclose(pFile);
        }

        if (!refDom.HasParseError())
        {
            bResult = true;
        }
        else
        {
           // TRACE("json parse error offset: %d", refDom.GetErrorOffset());
        }	    
    }

    return bResult;
}
#endif
