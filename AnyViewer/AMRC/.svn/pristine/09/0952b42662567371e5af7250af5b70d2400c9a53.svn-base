///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  
/// @brief 防水墙探头部分
/// 
/// 防水墙探头与服务器之间通信所需要的消息类型定义.所有的消息都由消息头和消息\n
/// 数据量部分组成，消息头的结构都是相同的，但是消息数据根据消息类型的不同而\n
/// 不同.整个协议请求&应答的模式。
///
/// @author 黄丽云
/// @version 1.0
/// @date        2016-9-1
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once
#pragma warning(disable : 4200) 
#include "MessageHeadDef.h"
#include "TreeManagerBase.h"
#include "MiscellaneousFunctions.h"
#include <memory>

#ifndef WIN32
#include <mutex>
#endif

namespace NetSCYProtocol
{
#define ACCOUNT_LENGTH_MAX 32
#define PASSWORD_LENGTH_MAX 32
#define FILE_NAME_LEN_MAX 255
#define MD5_LEN_MAX 32
#define TRANSACTION_STATUS_MSG_LEN_MAX 200   ///< 事务状态消息的最大长度

	/// 错误类型枚举
	/// 
	/// 五百以前的错误定位严重错误，连接将断开
	enum EXCEPTION_STATUS
	{
		// 用户登录相关
		ES_SUCCESS = 0,
		ES_INVALID_ACCOUNT = 1, 	///< 枚举，账号不存在
		ES_CREATE_ACCOUNT_FAILED = 2,  ///<创建账号失败
		ES_INVALID_NAME = 3, 	    ///< 枚举，无效的名称
		ES_EXIST_NAME = 4, 	        ///< 枚举，名称已经存在
		ES_INVALID_PASSWD = 5, 	    ///< 枚举，密码错误
		ES_REPEAT_LOGIN = 6, 		///< 枚举，重复登录
		ES_TIME_OUT = 7,             ///< 枚举，超时
		ES_NOT_LOGGED_IN = 8,        ///< 枚举，未登录
		ES_NOT_FOUND_TRANS = 9,      ///< 枚举，没有找到指定的事物
		ES_RETRANSFER = 10,      ///< 枚举，传输数据失败
		ES_ALLOCATE_TRANS_UNSUCCESSFULLY = 11,      ///< 枚举，分配事务上下文失败
		ES_OPEN_FILE_UNSUCCESSFULLY = 12,      ///< 枚举，打开文件失败
		ES_SERVICE_ERR = 13,          ///<服务器错误
		ES_INVALID_SN = 14,           ///<无效激活码
		ES_REACH_AUTHORIZATION_LIMIT = 15,          ///< 授权数已经满,无法在激活
		ES_SEND_FAILED = 16,
		ES_DB_ERROR = 17,        ///< 枚举，数据库错误
		MT_TRANSFER_STREAM = 18,	                ///< 枚举，传输数据流
		MT_TRANSFER_STREAM_DATA = 19,	        ///< 枚举，传输数据流数据
		MT_SYN_STREAM = 20,	                    ///< 枚举，同步数据流
		MT_ABORT_TRANSFER_STREAM = 21,          ///< 枚举，终止数据流数据传输
		MT_MOVE_STREAM_OFFSERT = 2,            ///< 枚举，移动传输数据流数据偏移
		ES_UNKNOWN_ERR,          ///< 枚举，未知的错误	
	};

	struct STATUS_CODE_DESC
	{
		EXCEPTION_STATUS m_nStatusCode;
		std::string m_strDesc;
	};



	//所有的消息类型一览表
	enum  MESSAGE_TYPE
	{
		MT_UNKNOWN = 0,
		MT_AES_ENCIPHER_KEY = 1,
		MT_QUERY_ONLINE = 2,			        ///< 枚举，查询登录状态,参考:QUERY_ONLINE_RESPONSE
		MT_LOGIN = 3,                           ///< 枚举，登录  
		MT_LOGOUT = 4,                          ///< 枚举，注销求  
		MT_CRAETE_ACCOUNT = 5,                  ///< 枚举，创建账号
		MT_CRAETE_SN = 6,                       ///< 枚举，创建授权信息
		MT_CHANGE_CLIENT_STATUS = 7,
		MT_NOTIFY_LOGOUT = 8,
		MT_KICK_OFF = 9,
		MT_NOTIFY_LOGIN = 10,
		MT_ACTIVE = 11,                         ///< 枚举，激活产品
		MT_HEARTBEAT = 18,                      ///< 心跳数据
		MT_EVENT_NOTIFACTION = 19,              ///< 枚举，事件
		MT_SENSOR_ID = 20,                      ///< 枚举，探头身份信息
		MT_QUERY_CUSTOMER_INFO = 21,            ///< 枚举，查询客户信息
		MT_UPDATE_CUSTOMER_INFO = 22,           ///< 枚举，更新客户信息
		MT_QUERY_SERVER_TIME = 23,              ///< 枚举，查询服务器时间
		MT_MAX_MSG_COUNT,			            ///< 枚举，消息类型最大数, 该值位于MESSAGE_TYPE最后一位
	};




	// 客户端状态类型枚举定义
	enum  COST_CLIENT_STATUS
	{
		CCS_OFF_LINE = 0,                 ///< 枚举，离线
		CCS_ON_LINE = 0X01,               ///< 枚举，在线
		CCS_BUSY = 0X02,                  ///< 枚举，忙碌
		CCS_HIDE = 0X03,                  ///< 枚举，隐藏	
	};


	// 探头类型枚举定义
	enum  SENSOR_TYPE
	{
		ST_UNKNOWN = 0,               ///< 枚举，未知
		ST_UNICORN = 1,
		ST_SAX2 = 2,
		ST_SCOUT = 3,
	};


	// 必须用下面这种对齐方式，不能用#pragma pack(1)
#pragma  pack (push,1)

	// -------------------------两个通用的消息定义，不携带任何数据---------------

	/// @brief 查询登录状态请求
	typedef struct _common_request
	{
		MESSAGE_HEADER objMsgHeader;
		U32                     nStatusCode;   ///< 返回响应结果状态码
	}COMMON_REQUEST;

	/// @brief 登录响应
	typedef struct  _common_response
	{
		MESSAGE_HEADER objMsgHeader;
		U32                     nStatusCode;   ///< 返回响应结果状态码
	}COMMON_RESPONSE;

	/// @brief 心跳报
	typedef struct _common_heartbeat
	{
		MESSAGE_HEADER objMsgHeader;
		U32                     nStatusCode;   ///< 返回响应结果状态码
	}COMMON_HEARTBEAT;

	/// <summary>转发头</summary>
	typedef struct _transpond_header
	{
		MESSAGE_HEADER objMsgHeader;
		U32 nSrcAccount;
		U32 nDstAccount;
	}TRANSPOND_HEADER;


	typedef struct  _common_transpond_response
	{
		TRANSPOND_HEADER objTranspondHeader;
		U32                     nStatusCode;   ///< 返回响应结果状态码
	}COMMON_TRANSPOND_RESPONSE;

	/*-------------------------AES加密KEY消息格式定义---------------------------------------------*/

	/// @brief 查询登录状态响应
	/// 
	/// 传输方向：客户端-->服务器\n
	/// 响应：消息AES_ENCIPHER_KEY_REQUEST的响应消息格式是AES_ENCIPHER_KEY_RESPONSE
	///            它们是相同
	typedef struct  _aes_encipher_key
	{
		MESSAGE_HEADER objMsgHeader;
		char  szKeyData[48];                                  ///< 解密后的数据只有前面16个有效，剩下全是填充数据
	}AES_ENCIPHER_KEY_REQUEST, AES_ENCIPHER_KEY_RESPONSE;

	/*-------------------------用户登录部分的消息格式定义---------------------------------------------*/


	typedef COMMON_RESPONSE CREATE_ACCOUNT_RESPONSE;


	/// @brief 查询登录状态响应
	/// 
	/// 传输方向：客户端-->服务器
	typedef struct  _query_online_response
	{
		MESSAGE_HEADER objMsgHeader;
		U32  bOnline;                                  ///< 登录状态(TRUE:在线，FALSE:离线)
		char szName[ACCOUNT_LENGTH_MAX];							   ///< 用户名称
	}QUERY_ONLINE_RESPONSE;

	/// @brief 登录请求
	/// 
	/// 传输方向：客户端-->服务器
	typedef struct  _login_request
	{
		MESSAGE_HEADER objMsgHeader;
		char szAccount[ACCOUNT_LENGTH_MAX];		  	       ///< 用户名称
		char szPassword[PASSWORD_LENGTH_MAX];              ///< 密码	
	}LOGIN_REQUEST;

	/// @brief 登录响应
	/// 
	/// 传输方向：客户端<--服务器
	typedef struct  _login_response
	{
		MESSAGE_HEADER objMsgHeader;
		union
		{
			U32 nAccount;             ///< 账号(成功)
			U32 nStatusCode;          ///<状态码(失败)
		};
		U32 nType;                     ///< 类型
	}LOGIN_RESPONSE;



	/// @brief 注销
	/// 
	/// 传输方向：客户端-->服务器

	typedef struct  _logout_request
	{
		MESSAGE_HEADER objMsgHeader;
		char szAccount[ACCOUNT_LENGTH_MAX];		  	       ///< 用户名称
	}LOGOUT_REQUEST;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 请求传输消息
	/// </summary>
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	typedef struct  _change_client_status
	{
		MESSAGE_HEADER objMsgHeader;
		U32 nAccount;            ///< 账号	
		U32 nStatus;             ///< 新的状态,@see COST_CLIENT_STATUS
	}CHANGE_CLIENT_STATUS;

	
	// --------------------------------------------------------------------------------
/// <summary>
/// 事务请求
/// </summary>
// --------------------------------------------------------------------------------
	typedef struct  _transfer_stream_request
	{
		MESSAGE_HEADER objMsgHeader;
		U16 nType;                   ///< 数据类型 @see STREAM_DATA_TYPE
		U64 nId;                   ///< 事务id
		U32 nSrcAccount;           ///<源账号
		U32 nDstAccount;           ///<目的账号
		I8 szMd5[MD5_LEN_MAX + 1];              ///< md5
		U64 nSize;                 ///< 大小
	}TRANSFER_STREAM_REQUEST;


	// --------------------------------------------------------------------------------
	/// <summary>
	/// 同步流事务请求
	/// </summary>
	// --------------------------------------------------------------------------------
	typedef struct  _syn_stream_request
	{
		MESSAGE_HEADER objMsgHeader;
		U16 nType;                   ///< 数据类型 @see STREAM_DATA_TYPE
		U64 nId;                   ///< 源事务id
		U32 nSrcAccount;            ///<源账号
		U32 nDstAccount;            ///<目的账号
		I8 szMd5[MD5_LEN_MAX + 1];              ///< md5
		U64 nSize;                 ///< 大小
	}SYN_STREAM_REQUEST;


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 流应答数据包
	/// </summary>
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	typedef struct  _transfer_stream_response
	{
		MESSAGE_HEADER objMsgHeader;
		U64 nId;       ///< 流源ID
		U64 nStatusCode;     ///< 返回响应结果状态码
	}TRANSFER_STREAM_RESPONSE;

	// --------------------------------------------------------------------------------
	/// <summary>
	/// 中止数据流传输事务
	/// </summary>
	// --------------------------------------------------------------------------------
	typedef struct  _abort_transfer_stream_request
	{
		MESSAGE_HEADER objMsgHeader;
		U64 nId;                   ///< 事务id
	}ABORT_TRANSFER_STREAM_REQUEST;

	// --------------------------------------------------------------------------------
	/// <summary>
	/// 事务实体
	/// </summary>
	// --------------------------------------------------------------------------------
	typedef struct  _transfer_stream_data_request
	{
		MESSAGE_HEADER objMsgHeader;
		U64 nId;                   ///< 事务id
		U32 nSize;                 ///< 大小
		U64 nOffset;               ///< 偏移
	}TRANSFER_STREAM_DATA_REQUEST;



	/// @brief 传输数据流应答数据包
	typedef struct  _transfer_stream_data_response
	{
		MESSAGE_HEADER objMsgHeader;
		U64 nId;             ///< 事务id
		U64 nOffset;         ///< 下一个偏移
		U32 nStatusCode;     ///< 返回响应结果状态码
	}TRANSFER_STREAM_DATA_RESPONSE;


	// --------------------------------------------------------------------------------
	/// <summary>
	/// 移动数据流读偏移,用于断点续传
	/// </summary>
	// --------------------------------------------------------------------------------
	typedef struct  _move_stream_offsert_request
	{
		MESSAGE_HEADER objMsgHeader;
		U64 nId;             ///< 事务id
		U64 nOffset;               ///< 偏移
	}MOVE_STREAM_OFFSET_REQUEST;


	// --------------------------------------------------------------------------------
	/// <summary>
	/// 移动数据流读偏移,用于断点续传
	/// </summary>
	// --------------------------------------------------------------------------------
	typedef struct  _move_stream_offsert_reponse
	{
		MESSAGE_HEADER objMsgHeader;
		U64 nId;             ///< 事务id
		U64 nOffset;      ///< 偏移
		U32 nStatusCode;  ///< 返回响应结果状态码
	}MOVE_STREAM_OFFSET_REPONSE;




	/// @brief 发送探头身份信息到服务器
	/// 
	/// 传输方向：探头->消息中心
	typedef struct
	{
		MESSAGE_HEADER objMsgHeader;
		U32            nID;           ///< 探头ID
		char           szName[32];    ///< 探头名称
		U16            nType;         ///< 探头类型,@see SENSOR_TYPE
	}SENSOR_ID_INFO;


	/// @brief 查询服务器时间
	/// 
	/// 传输方向：服务器-->客户端
	typedef struct  _query_svr_time_response
	{
		MESSAGE_HEADER objMsgHeader;
		U64  nTime;                                  ///< 服务器时间
	}QUERY_SVR_TIME_RESPONSE;

#pragma pack(pop)
	
	//*******************************************************************
		/// <summary>
		/// 基本账号信息，当用户登陆成功后用于传输朋友账号
		/// </summary>
		//*******************************************************************
	class CBaseAccountInfo :public CSerializeEntry
	{
	public:
		CBaseAccountInfo(const char* pName = "");
		virtual ~CBaseAccountInfo();
		CBaseAccountInfo(const CBaseAccountInfo& refBaseAccountInfo);
		CBaseAccountInfo& operator=(const CBaseAccountInfo& refBaseAccountInfo);

		ENABLE_SERIALIZE(CBaseAccountInfo)
	public:
		virtual void Serialize(CJSONSerializer& refJsonSerializer) const override;

		virtual void DeSerialize(CJSONSerializer& refJsonSerializer) override;

	private:
		DECLARE_MEMBER_AND_METHOD(I64, m_nID, ID)      ///< 账号 
		DECLARE_MEMBER_AND_METHOD(std::string, m_strAccount, Account)      ///< 账号 
		DECLARE_MEMBER_AND_METHOD(int, m_nType, Type)            ///< 类型 @see COST_CLIENT_TYPE
		DECLARE_MEMBER_AND_METHOD(std::string, m_strName, Name) ///< 会员名称
		DECLARE_MEMBER_AND_METHOD(std::string, m_strMemo, Memo)    ///< 备注
	};

	typedef CDynamicJsonVector<CBaseAccountInfo> ACCOUNT_ARRAY;

	//*******************************************************************
	/// <summary>
	/// 客户信息类，用于注册和更新账号信息
	/// </summary>
	//*******************************************************************
	class CAccountInfo :public CBaseAccountInfo
	{
	public:
		CAccountInfo(const char* pName = "", const char* pPwd = "");
		CAccountInfo(const CAccountInfo& refCAccountInfo);
		CAccountInfo& operator=(const CAccountInfo& refCAccountInfo);

	public:
		virtual void Serialize(CJSONSerializer& refJsonSerializer) const override;

		virtual void DeSerialize(CJSONSerializer& refJsonSerializer) override;

	public:
		DECLARE_MEMBER_AND_METHOD(std::string, m_strPWD, PWD)    ///< 口令
		DECLARE_MEMBER_AND_METHOD(std::string, m_strTel, Tel)    ///< 电话号码
		DECLARE_MEMBER_AND_METHOD(std::string, m_strCompany, Company)    ///< 公司名称
		DECLARE_MEMBER_AND_METHOD(std::string, m_strEmail, Email)    ///< 电子邮件
		DECLARE_MEMBER_AND_METHOD(std::string, m_strWeb, Web)    ///< 主页
		DECLARE_MEMBER_AND_METHOD(std::string, m_strAddr, Addr)    ///< 公司地址

		DECLARE_MEMBER_AND_METHOD(int, m_nMoney, Money)    ///< 钱(分)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strMachineID, MachineID)    ///< 机械码
		DECLARE_MEMBER_AND_METHOD(int, m_nIP, IP)    ///< 注册地ip地址
		DECLARE_MEMBER_AND_METHOD(std::string, m_strUnionid, Unionid)    ///< 微信唯一标识Unionid
		DECLARE_MEMBER_AND_METHOD(std::string, m_strNickname, Nickname)    ///< 昵称
		DECLARE_MEMBER_AND_METHOD(bool, m_bSex, Sex)    ///< 性别true男性
	};


	//*******************************************************************
	/// <summary>
	/// 创建许可信息参数
	/// </summary>
	//*******************************************************************
	class CCreateSNArgus :public CSerializeEntry
	{
	public:
		CCreateSNArgus();
		virtual ~CCreateSNArgus();


		ENABLE_SERIALIZE(CCreateSNArgus)

	public:
		virtual void Serialize(CJSONSerializer& refJsonSerializer) const override;

		virtual void DeSerialize(CJSONSerializer& refJsonSerializer) override;

	private:
		DECLARE_MEMBER_AND_METHOD(unsigned int, m_nSNs, SNs)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strProduct, Product)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strEdition, Edition)
		DECLARE_MEMBER_AND_METHOD(unsigned int, m_nCurrentVersion, CurrentVersion)
		DECLARE_MEMBER_AND_METHOD(unsigned int, m_nMaxVersion, MaxVersion)
		DECLARE_MEMBER_AND_METHOD(unsigned int, m_nLicenseNumber, LicenseNumber)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strLanguage, Language)
		DECLARE_MEMBER_AND_METHOD(unsigned int, m_nDefaultSubscription, DefaultSubscription)
		DECLARE_MEMBER_AND_METHOD(int, m_nType, Type)
	};


	//*******************************************************************
	/// <summary>
	/// 创建许可信息参数
	/// </summary>
	//*******************************************************************
	class CSNInfo :public CSerializeEntry
	{
	public:
		CSNInfo() {}
		CSNInfo(const std::string& szActivationCodes);
		virtual ~CSNInfo();


		ENABLE_SERIALIZE(CSNInfo)

	public:
		virtual void Serialize(CJSONSerializer& refJsonSerializer) const override;

		virtual void DeSerialize(CJSONSerializer& refJsonSerializer) override;

	private:

		DECLARE_MEMBER_AND_METHOD(std::string, m_strActivationCodes, ActivationCodes)
	};

	typedef CDynamicJsonVector<CSNInfo>  SN_INFO_ARRAY;


	//*******************************************************************
	/// <summary>
	/// 创建许可信息参数
	/// </summary>
	//*******************************************************************
	class CActivtionArgus :public CSerializeEntry
	{
	public:
		CActivtionArgus() {}
		virtual ~CActivtionArgus() {}


		ENABLE_SERIALIZE(CActivtionArgus)

	public:
		virtual void Serialize(CJSONSerializer& refJsonSerializer) const override
		{
			CSerializeEntry::Serialize(refJsonSerializer);

			refJsonSerializer.Serialize("m10", m_strActivationCode);
			refJsonSerializer.Serialize("m11", m_strKey);
		}

		virtual void DeSerialize(CJSONSerializer& refJsonSerializer) override
		{
			CSerializeEntry::DeSerialize(refJsonSerializer);

			refJsonSerializer.DeSerialize("m10", m_strActivationCode);
			refJsonSerializer.DeSerialize("m11", m_strKey);
		}

	private:
		DECLARE_MEMBER_AND_METHOD(std::string, m_strActivationCode, ActivationCode)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strKey, Key)
	};

	//*******************************************************************
	/// <summary>
	/// 创建许可信息参数
	/// </summary>
	//*******************************************************************
	class CLicenseData :public CSerializeEntry
	{
	public:
		CLicenseData() {}
		virtual ~CLicenseData() {}

		ENABLE_SERIALIZE(CLicenseData)

	public:
		virtual void Serialize(CJSONSerializer& refJsonSerializer) const override
		{
			CSerializeEntry::Serialize(refJsonSerializer);

			refJsonSerializer.Serialize("m10", m_strData);
		}

		virtual void DeSerialize(CJSONSerializer& refJsonSerializer) override
		{
			refJsonSerializer.DeSerialize("m10", m_strData);
		}
	private:
		DECLARE_MEMBER_AND_METHOD(std::string, m_strData, Data)
	};

	//*******************************************************************
	/// <summary>
	/// 创建许可信息参数
	/// </summary>
	//*******************************************************************
	class CLicenseInfo : public CSerializeEntry
	{
	public:
		CLicenseInfo() {}
		virtual ~CLicenseInfo() {}

		ENABLE_SERIALIZE(CLicenseInfo)

	public:
		virtual void Serialize(CJSONSerializer& refJsonSerializer) const override
		{
			CSerializeEntry::Serialize(refJsonSerializer);

			refJsonSerializer.Serialize("m10", m_strContact);
			refJsonSerializer.Serialize("m11", m_strCompany);
			refJsonSerializer.Serialize("m12", m_strProduct);
			refJsonSerializer.Serialize("m13", m_strEdition);
			refJsonSerializer.Serialize("m14", m_strSN);
			refJsonSerializer.Serialize("m15", m_nMaxVersion);
			refJsonSerializer.Serialize("m16", m_nLicenseNumber);
			refJsonSerializer.Serialize("m17", m_nActivationDate);
			refJsonSerializer.Serialize("m18", m_nSubscription);
			refJsonSerializer.Serialize("m19", m_nType);
		}

		virtual void DeSerialize(CJSONSerializer& refJsonSerializer) override
		{
			CSerializeEntry::DeSerialize(refJsonSerializer);

			refJsonSerializer.DeSerialize("m10", m_strContact);
			refJsonSerializer.DeSerialize("m11", m_strCompany);
			refJsonSerializer.DeSerialize("m12", m_strProduct);
			refJsonSerializer.DeSerialize("m13", m_strEdition);
			refJsonSerializer.DeSerialize("m14", m_strSN);
			refJsonSerializer.DeSerialize("m15", m_nMaxVersion);
			refJsonSerializer.DeSerialize("m16", m_nLicenseNumber);
			refJsonSerializer.DeSerialize("m17", m_nActivationDate);
			refJsonSerializer.DeSerialize("m18", m_nSubscription);
			refJsonSerializer.DeSerialize("m19", m_nType);
		}

		I64 GetExpirationTime() { return m_nActivationDate + m_nSubscription * 31 * 24 * 3600; }

	private:
		DECLARE_MEMBER_AND_METHOD(std::string, m_strContact, Contact)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strCompany, Company)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strProduct, Product)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strEdition, Edition)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strSN, SN)
		DECLARE_MEMBER_AND_METHOD(unsigned int, m_nMaxVersion, MaxVersion)
		DECLARE_MEMBER_AND_METHOD(unsigned int, m_nLicenseNumber, LicenseNumber)
		DECLARE_MEMBER_AND_METHOD(I64, m_nActivationDate, ActivationDate)
		DECLARE_MEMBER_AND_METHOD(unsigned int, m_nSubscription, Subscription)
		DECLARE_MEMBER_AND_METHOD(int, m_nType, Type)

	};


	//*******************************************************************
	/// <summary>
	/// 客户信息
	/// </summary>
	//*******************************************************************
	class CCustomerInfo : public CSerializeEntry
	{
	public:
		CCustomerInfo() {}
		virtual ~CCustomerInfo() {}

		ENABLE_SERIALIZE(CCustomerInfo)

	public:
		virtual void Serialize(CJSONSerializer& refJsonSerializer) const override
		{
			CSerializeEntry::Serialize(refJsonSerializer);

			refJsonSerializer.Serialize("m10", m_strSN);
			refJsonSerializer.Serialize("m11", m_strContact);
			refJsonSerializer.Serialize("m12", m_strCompany);
			refJsonSerializer.Serialize("m13", m_strJob);
			refJsonSerializer.Serialize("m14", m_strTel);
			refJsonSerializer.Serialize("m15", m_strPost);
			refJsonSerializer.Serialize("m16", m_strEmail);
			refJsonSerializer.Serialize("m17", m_strState);
			refJsonSerializer.Serialize("m18", m_strProvince);
			refJsonSerializer.Serialize("m19", m_strCity);
			refJsonSerializer.Serialize("m20", m_strAddr);
		}

		virtual void DeSerialize(CJSONSerializer& refJsonSerializer) override
		{
			CSerializeEntry::DeSerialize(refJsonSerializer);

			refJsonSerializer.DeSerialize("m10", m_strSN);
			refJsonSerializer.DeSerialize("m11", m_strContact);
			refJsonSerializer.DeSerialize("m12", m_strCompany);
			refJsonSerializer.DeSerialize("m13", m_strJob);
			refJsonSerializer.DeSerialize("m14", m_strTel);
			refJsonSerializer.DeSerialize("m15", m_strPost);
			refJsonSerializer.DeSerialize("m16", m_strEmail);
			refJsonSerializer.DeSerialize("m17", m_strState);
			refJsonSerializer.DeSerialize("m18", m_strProvince);
			refJsonSerializer.DeSerialize("m19", m_strCity);
			refJsonSerializer.DeSerialize("m20", m_strAddr);
		}

	private:
		DECLARE_MEMBER_AND_METHOD(std::string, m_strSN, SN)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strContact, Contact)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strCompany, Company)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strJob, Job)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strTel, Tel)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strPost, Post)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strEmail, Email)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strState, State)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strProvince, Province)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strCity, City)
		DECLARE_MEMBER_AND_METHOD(std::string, m_strAddr, Addr)
	};

	extern std::string GetStatusCodeDesc(EXCEPTION_STATUS nStatusCode);
}


