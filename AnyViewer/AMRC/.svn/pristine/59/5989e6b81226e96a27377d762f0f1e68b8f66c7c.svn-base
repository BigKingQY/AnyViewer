/////////////////////////////////////////////////////////////////////
/// @file PrjSettings.h
/// @brief 工程设置类定义
/// 
/// @author andy
/// @version 1.0
/// @date 2020.10.15
/////////////////////////////////////////////////////////////////////
#pragma once
#include "ECC.h"
#include "PortMappingContainer.h"
#include "JsonSerializer.h"
#include "MiscellaneousFunctions.h"
#include "StringVector.h"
#include "ConnectionConfig.h"
#include <mutex>


// --------------------------------------------------------------------------------
/// <summary>
/// 连接过历史伙伴账号
/// </summary>
// --------------------------------------------------------------------------------
class CHistoryPartner : public CSerializeEntry
{
public:
	CHistoryPartner() {}
	CHistoryPartner(const std::string& refDeviceID)
		: m_strDeviceID(refDeviceID)
	{}
	~CHistoryPartner() {}

	CHistoryPartner& operator=(const CHistoryPartner& refSrc);

	ENABLE_SERIALIZE(CHistoryPartner)
public:
	//序列化设置信息
	virtual void Serialize(CJSONSerializer& refJsonSerializer) const override;

	//反序列化设置信息
	virtual void DeSerialize(CJSONSerializer& refJsonSerializer) override;

private:
	///< 从服务器获取的设备ID，不需要保存
	DECLARE_MEMBER_AND_METHOD(std::string, m_strDeviceID, DeviceID);

	///< 用户登录使用的口令
	DECLARE_MEMBER_AND_METHOD(std::string, m_strPwd, Pwd);
};

using CHistoryPartnerPtr = std::shared_ptr<CHistoryPartner>;
using CHistoryPartnerArray = CSharedDynamicJsonVector<CHistoryPartner>;


class CPrjSettings : public CSerializeEntry
{
public:
	CPrjSettings();
	virtual ~CPrjSettings();

	CPrjSettings(const CPrjSettings& refSrc);

	CPrjSettings& operator=(const CPrjSettings& refSrc);


	/// <summary>图像质量类型枚举定义</summary>
	enum IMAGE_QUALITY_TYPE
	{
		IQT_AUTOMATIC = 0,               ///< 枚举常量,自动
		IQT_IMAGE_QUALITY_PRIORITY = 1,  ///< 枚举常量,图像质量优先
		IQT_DISPLAY_SPEED_PRIORITY = 2,  ///< 枚举常量,速度优先
	};

	/// <summary>语言类型定义</summary>
	enum LANGUAGE_TYPE
	{
		LT_UNKNOWN = 0,        ///< 枚举常量,未知
		LT_ENGLISH = 1033,    ///< 枚举常量,英文
		LT_CHINEASE = 2052,   ///< 枚举常量,中文(简体)
		LT_GERMAN = 1031,   ///< 枚举常量,德语
		LT_FRENCH = 1036,   ///< 枚举常量,法语
		LT_ITALIAN = 1040,   ///< 枚举常量,意大利语
		LT_SPANISH = 1034,   ///< 枚举常量,西班牙语
		LT_JAPANESE = 1041,   ///< 枚举常量,日语
		LT_CHINESETW = 1028,   ///< 枚举常量,中文(繁体)
	};

	/// <summary>主题类型</summary>
	enum THEME_TYPE
	{
		TT_FOLLOW_SYSTEM = 0,    ///< 枚举常量,
		TT_LIGHT_MODE = 1,       ///< 枚举常量,
		TT_DARK_MODE = 2,        ///< 枚举常量,
	};

	/// <summary>校验密码的结果类型定义</summary>
	enum VALID_PWD_RET
	{
		VPR_INVALID = 0,    ///< 枚举常量,不合法
		VPR_EMPTY = 1,    ///< 枚举常量,空
		VPR_TOO_SHORT = 2,    ///< 枚举常量,太短
		VPR_TOO_SIMPLE = 4,    ///< 枚举常量,太简单
		VPR_VALID = 8,    ///< 枚举常量,合法
	};

	/// <summary>口令的安全强度</summary>
	enum PASSWORD_SECURITY_STRENGTH
	{
		PSS_INVALID = 0,         ///< 枚举常量,无效
		PSS_DANGER = 1,          ///< 枚举常量,危险
		PSS_LOW_DANGER = 2,      ///< 枚举常量,风险
		PSS_SECURE = 3,          ///< 枚举常量,安全
		PSS_HIGH_SECURE = 4,     ///< 枚举常量,非常安全
	};

	/// <summary>断开连接后的操作类型枚举</summary>
	enum DISCONNECT_ACTION_TYPE 
	{
		DA_DO_NOTHING = 0,           ///< 枚举常量,什么都不做(默认)
		DA_LOCK_WORKSTATION = 1,     ///< 枚举常量,锁住工作台
		DA_LOGOUT_WORKSTATION = 2    ///< 枚举常量,注销工作台
	};

	using CUINTArray = CStaticJsonVector<unsigned int>;

public:
	CUINTArray& GetRouteIPs() { std::lock_guard<std::recursive_mutex> objLocker(m_objMutex);  return m_arrRouteIPs; }

	// 设置指定跳数的路由IP
	void SetRouteIP(const unsigned int nTTL, const unsigned int nIP);

	// 得到指定跳数的路由IP
	unsigned int GetRouteIP(const unsigned int nTTL);

	// 得到所有路由IP，多个ip地址用分号分割
	std::string GetRouteIPsAsString() const;

	//  清除无效的路由IP
	void ClearInvalidRouteIP();

	///< 固定口令，用户设置
	std::string GetPwd() const { std::lock_guard<std::recursive_mutex> objLocker(m_objMutex);  return m_strPwd; }

	///< 得到别名
	std::string GetNickName() const { std::lock_guard<std::recursive_mutex> objLocker(m_objMutex);  return m_strNickName; }

	///< 得到服务器IP
	std::string GetServerIP() const { std::lock_guard<std::recursive_mutex> objLocker(m_objMutex);  return m_strServerIP; }

	/// 得到当前语言的tag
	std::string GetLanguageTag();
public:
	//< 增加历史伙伴记录
	void AppendHistoryPartner(CHistoryPartnerPtr pHistoryPartner);

	// 查找历史伙伴
	CHistoryPartnerPtr LookupHistoryPartner(const std::string& refDeviceID) const;

	// 得到历史伙伴列表
	const CHistoryPartnerArray& GetHistoryPartner() const;

	// 清除所有的历史会话记录
	void ClearAllHistoryPartner();

	// 清除所有的历史会话记录的安全码
	void ClearAllHistoryPartnerSecCode();
public:
	// 校验密码是否合法
	VALID_PWD_RET VerifyPwd(const std::string& refPwd) const;

	// 分析密码的安全性
	PASSWORD_SECURITY_STRENGTH AnalyzePwdSecurity(const std::string& refPwd) const;

public:
	//序列化设置信息
	virtual void Serialize(CJSONSerializer& refJsonSerializer) const override;

	//反序列化设置信息
	virtual void DeSerialize(CJSONSerializer& refJsonSerializer) override;

public:
	//保存工程设置到磁盘文件
	bool Save(const std::string& refPath) const;

	//从磁盘文件加载工程设置
	bool Load(const std::string& refPath);

	// 启用默认设置
	void DefaultSettings();

	// 回复设置
	void Reconver(CPrjSettings& refSrc);
public:
	// 设置aes加密key
	void SetAESEncipherKey(const UCHAR* pKey);

	// 判断当前的密码是否是比较简单
	bool IsSimplePwd(const std::string& refPwd) const;

	// 解密口令
	std::string DecryptPwd(const std::string& refPwd) const;

	// 加密口令
	std::string EncryptPwd(const std::string & refPwd) const;

private:
	///<aes加密对象,用于加密发送数据  
	struct aes_ctx                      m_objAESEncipherKey;             

	///< 加载或保存锁
	mutable std::recursive_mutex        m_objMutex;

	///< 启用该选项后，才可以接受其它控制者的请求
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bEnableCtrl, EnableCtrl, true);

	///< 是否允许临时口令,启用该选项后，应用程序会产生一个临时口令
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bEnableTmpPwd, EnableTmpPwd, true);

	///< 从服务器获取的设备ID，不需要保存
	DECLARE_MEMBER_AND_METHOD(std::string, m_strDeviceID, DeviceID);

	///< 临时口令，不需要保存
	DECLARE_MEMBER_AND_METHOD(std::string, m_strTmpPwd, TmpPwd);

	///< 是否允许临时口令,启用该选项后，应用程序会产生一个临时口令
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bEnableFixPwd, EnableFixPwd, false);

	///< 固定口令，用户设置
	DECLARE_MEMBER_AND_SET_METHOD(std::string,m_strPwd, Pwd);

	///< 昵称
	DECLARE_MEMBER_AND_SET_METHOD_V11(std::string, m_strNickName, NickName,"");

	///< 图形质量类型设置,@see IMAGE_QUALITY_TYPE
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nImageQuality, ImageQuality, IQT_IMAGE_QUALITY_PRIORITY);

	///< 是否影藏桌面壁纸
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bHideWallPage, HideWallPage, false);

	///< 自动启动,随windows启动
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bAutoStart, AutoStart, true);

	///< 系统使用的语言类型(如果是LT_UNKNOWN，系统将自动检测),@see LANGUAGE_TYPE
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nLanguage, Language, LT_ENGLISH);

	///< 主题类型,@see THEME_TYPE
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nTheme, Theme, TT_FOLLOW_SYSTEM);

	///< RC控制服务器IP地址
	DECLARE_MEMBER_AND_SET_METHOD_V11(std::string, m_strServerIP, ServerIP,"controlserver.anyviewer.com");
	
	///< RC控制服务器端口
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nPort, Port, 30192);

	///< When flag is set server always blocks local input.
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bLockLocalInput, LockLocalInput, false);

	///< When flag is set server blocks remote input on local input activity.
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bLocalInputPriority, LocalInputPriority, false);

	//
// Local input invactivity timeout during that
// we still blocking remote input(when m_localInputPriority
// is enabled).
//
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nLocalInputPriorityTimeout, LocalInputPriorityTimeout, 3);

	// 需要保存的日志等级
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nLogLevel, LogLevel, CLogger::LEVEL_ERROR);

	///<  Polling configuration
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nPollingInterval, PollingInterval, 50);

	///< 
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bGrabTransparentWindowsFlag, GrabTransparentWindowsFlag, true);

	///< 
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bMirrorDriverAllowed, MirrorDriverAllowed, false);

	///< 
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bD3DAllowed, D3DAllowed, true);

	///< 
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bBlockRemoteInput, BlockRemoteInput, false);

	///< 服务器端口
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nRFBPort, RFBPort, 30193);

	///< 断开连接操作
	DECLARE_MEMBER_AND_METHOD_V11(DISCONNECT_ACTION_TYPE, m_nDisconnectAction, DisconnectAction, DA_DO_NOTHING);

	///< 是否总是共享桌面
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bAlwaysShared, AlwaysShared, false);

	///< 是否绝不共享桌面
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bNeverShared, NeverShared, true);

	///< 是否断当前存在的连接
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bDisconnectClients, DisconnectClients, true);
	
	/// 是否允许输入Ctrl+Alt+Del组合键
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bCtrlAltDelEnabled, CtrlAltDelEnabled,true);

	/// 客户端是否愿意共享桌面 
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bShared, SharedFlag, false);


	///< 连接配置设置
	DECLARE_MEMBER_AND_METHOD(CConnectionConfig, m_objConnectionConfig, ConnectionConfig);	

	///< 是否分析了网络环境
	DECLARE_MEMBER_AND_METHOD_V11(bool,m_bAnalyzedNetEnv, AnalyzedNetEnv,false);

	///< 路由IP表
	CUINTArray               m_arrRouteIPs;

	///< 控制服务器端口
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nConsolePort, ConsolePort, 30196);

	///< 接收屏幕采集数据的端口
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nScreenCapPort, ScreenCapPort, 30197);

	///< 历史伙伴记录列表
	CHistoryPartnerArray        m_arrHistoryPartners;

	///< 程序升级信息文件的URL地址
	DECLARE_MEMBER_AND_GET_METHOD_V11(std::string, m_strUpdateFileUrl, UpdateFileUrl, "http://www2.aomeisoftware.com/download/rc/rcupgrade.ini");

	/// < 用户是否参与体验计划
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bUserExperience, UserExperience, false);

	/// < 第一次使用的时间(距离1970-01-01 00:00:00的天数)
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nFirstTimeUse, FirstTimeUse, 0);

	/// < 最近一次使用的时间(距离1970-01-01 00:00:00的天数)
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nLastTimeUse, LastTimeUse, 0);

	/// < 忽略不需要升级的版本
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nIgnoretheversion, Ignoretheversion, 0);

	/// < 技术支持的连接
	DECLARE_MEMBER_AND_METHOD_V11(std::string, m_strTechnicalSupportURL, TechnicalSupportURL, "http://www.anyviewer.com/support.html");
	
	DECLARE_MEMBER_AND_METHOD(std::string, m_strRegion, Region);

	// 是否已经阅读初始化设置
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bInitSettingsReaded, InitSettingsReaded,false);

	/// < 帮助中心URL
	DECLARE_MEMBER_AND_METHOD_V11(std::string, m_strHepeCenterURL, HepeCenterURL, "https://anyviewer.aomeitech.com/support.html");

	/// < 邀请朋友URL
	DECLARE_MEMBER_AND_METHOD_V11(std::string, m_strInviteFriendsURL, InviteFriendsURL, "https://anyviewer.aomeitech.com/invite-friends.html");

	///< 系统使用的语言类型(如果是LT_UNKNOWN，系统将自动检测),@see LANGUAGE_TYPE
	DECLARE_MEMBER_AND_METHOD_V11(unsigned int, m_nOldLanguage, OldLanguage, LT_ENGLISH);

	///< 是否保存被控制端的安全码
	DECLARE_MEMBER_AND_METHOD_V11(bool, m_bSaveSecCode, SaveSecCode, true);

	///< 应用程序版本信息
	DECLARE_MEMBER_AND_METHOD_V11(int, m_nVersion, Version, 0);
};

using CPrjSettingsPtr = std::shared_ptr<CPrjSettings>;

extern CPrjSettings* GetPrjSettings();