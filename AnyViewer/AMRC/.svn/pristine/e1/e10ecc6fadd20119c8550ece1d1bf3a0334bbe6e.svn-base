///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  Word2Txt.cpp
/// 转换word文档到文本文件
/// 
///
/// 
/// @author 黄丽云
/// @version 1.0
/// @date        2018-10-22
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "Word2Txt.h"
#include <boost/locale.hpp>


CWord2Txt::CWord2Txt()
{
}


CWord2Txt::~CWord2Txt()
{
}


//--------------------------------------------------------------------------------
/// <summary>
/// 从word文档中读取内容并存储到指定的缓冲区中(是unicode编码)
/// </summary>
/// <param name="lpFile">指向读取的word文件</param>
/// <param name="refBuffer">存储数据的缓冲区</param>
/// <returns>true:成功,false:失败</returns>
/// <created>Andy,2019-06-03</created>
/// <changed>Andy,2019-06-03</changed>
//--------------------------------------------------------------------------------
bool CWord2Txt::Read(LPCTSTR lpFile, CBufferImplT<wchar_t>& refBuffer)
{
	bool bResult = false;

	HZIP hZip = OpenZip(lpFile, nullptr);

	if (nullptr != hZip)
	{
		ZIPENTRY objEntry = { 0 };
		int nIndex = 0;

		ZRESULT nZipResult = FindZipItem(hZip, _T("word/document.xml"), TRUE, &nIndex, &objEntry);

		if (ZR_OK == nZipResult)
		{
			CBufferImplT<unsigned char> objSrcBuffer;

			objSrcBuffer.Allocate(objEntry.unc_size + 1);
			nZipResult = UnzipItem(hZip, nIndex, objSrcBuffer, objEntry.unc_size);

			if (ZR_OK == nZipResult)
			{
				refBuffer.Allocate(objEntry.unc_size);
				objSrcBuffer.SetDataLen(objEntry.unc_size);

				/// <summary>分析状态</summary>
				enum ANALYSIS_STATUS
				{
					AS_INIT = 0,       ///< 位置状态
					AS_TAG_HEADER = 1,    ///< 标签头
					AS_CONTENT = 2,       ///< 内容
					AS_TAG_TAIL = 3,      ///< 标签尾
				};

				unsigned char chCurrent = 0;
				ANALYSIS_STATUS nStatus = AS_INIT;
				std::string strTagHeader;
				std::string strContent;

				for (size_t i = 0; i < size_t(objEntry.unc_size); i++)
				{					
					objSrcBuffer.Read(&chCurrent,1);

					switch (nStatus)
					{
					case AS_INIT:
					{
						if ('<' == chCurrent)
						{
							strTagHeader = chCurrent;
							nStatus = AS_TAG_HEADER;
						}
					}
					break;

					case AS_TAG_HEADER:
					{
						if ('>' == chCurrent)
						{
							if (strTagHeader.find("<w:t") != strTagHeader.npos)							
							{
								nStatus = AS_CONTENT;
							}
							else
							{
								nStatus = AS_INIT;
							}
						}
						else if ('/' == chCurrent)
						{
							nStatus = AS_INIT;
						}
						else
						{
							strTagHeader += chCurrent;
						}
					}
					break;

					case AS_CONTENT:
					{
						if ('<' == chCurrent)
						{
							nStatus = AS_TAG_TAIL;

							if (strContent.size() > 0)
							{
								std::wstring wStr = boost::locale::conv::utf_to_utf<wchar_t>(strContent);

								refBuffer.Write((wchar_t*)wStr.c_str(), wStr.size());
								strContent.clear();
							}
						}
						else
						{
							strContent += chCurrent;
						}

					}
					break;

					case AS_TAG_TAIL:
					{
						if ('>' == chCurrent)
						{
							nStatus = AS_INIT;
						}
					}
					break;

					default:
						break;
					}

				}

				bResult = true;
			}
		}

		CloseZip(hZip);
	}

	// 写入结束符号
	const wchar_t nEndsymbol = 0;
	refBuffer.Write(&nEndsymbol, 1);

	return bResult;
}



